<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>March on CodeWithStu's Blog</title><link>https://im5tu.io/article/2013/03/</link><description>Recent content in March on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2013/03/index.xml" rel="self" type="application/rss+xml"/><item><title>Semaphore vs SeamphoreSlim Micro Benchmark</title><link>https://im5tu.io/article/2013/03/semaphore-vs-seamphoreslim-micro-benchmark/</link><pubDate>Mon, 11 Mar 2013 18:06:28 +0000</pubDate><guid>https://im5tu.io/article/2013/03/semaphore-vs-seamphoreslim-micro-benchmark/</guid><description>&lt;p>In this post, I am going to show a small micro-benchmark to demonstrate the performance difference between the &lt;code>Semaphore&lt;/code> and &lt;code>SemaphoreSlim&lt;/code> classes in C#. A &lt;code>Semaphore&lt;/code> is often used to restrict the number of threads than can access some (physical or logical) resource. In this case, we want the restriction to be as little as possible.&lt;/p>
&lt;p>Semaphores are of two types: local semaphores and named system semaphores. If you create a Semaphore object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple Semaphore objects that represent the same named system semaphore, and you can use the OpenExisting method to open an existing named system semaphore. &lt;em>&lt;a href="http://msdn.microsoft.com/en-gb/library/system.threading.semaphore.aspx">Source&lt;/a>&lt;/em>&lt;/p>
&lt;p>A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local Semaphore object. Each Semaphore object is a separate local semaphore. &lt;em>&lt;a href="http://msdn.microsoft.com/en-gb/library/system.threading.semaphore.aspx">Source&lt;/a>&lt;/em>&lt;/p>
&lt;p>The machine that I am using for this benchmark is a Intel core i3, clocked at 4ghz with 4GB DDR3 ram running Windows 7 x64 SP1 and .Net Framework 4.5.&lt;/p>
&lt;p>In order to begin the test, I created a new console application and imported the BMark package from the &lt;a href="https://nuget.org/packages/BMark/">NuGet&lt;/a> repository. Next, I added the following code to the application as shown below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Int32 count = &lt;span style="color:#ae81ff">106&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Semaphore regularSemaphore = &lt;span style="color:#66d9ef">new&lt;/span> Semaphore(count, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SemaphoreSlim slimSemaphore = &lt;span style="color:#66d9ef">new&lt;/span> SemaphoreSlim(count, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UInt64 amountToRun = (UInt64)(count - PerformanceTester.PreRunAmount - &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PerformanceTester.Run(&lt;span style="color:#e6db74">&amp;#34;Semaphore.WaitOne&amp;#34;&lt;/span>, amountToRun, () =&amp;gt; { regularSemaphore.WaitOne(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PerformanceTester.Run(&lt;span style="color:#e6db74">&amp;#34;Semaphore.Release&amp;#34;&lt;/span>, amountToRun, () =&amp;gt; { regularSemaphore.Release(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PerformanceTester.Run(&lt;span style="color:#e6db74">&amp;#34;SemaphoreSlim.WaitOne&amp;#34;&lt;/span>, amountToRun, () =&amp;gt; { slimSemaphore.Wait(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PerformanceTester.Run(&lt;span style="color:#e6db74">&amp;#34;SemaphoreSlim.Release&amp;#34;&lt;/span>, amountToRun, () =&amp;gt; { slimSemaphore.Release(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Console.WriteLine(PerformanceTester.GetResults());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>By default, the &lt;code>PerformanceTester&lt;/code> will run each test 4 times before starting the actual timed test. Since we are dealing with a blocking resource, I added some extra capacity so that the test would not block at any point. When the code is run in release mode without the debugger, the output of the program is:&lt;/p>
&lt;pre tabindex="0">&lt;code> Semaphore.WaitOne: 0.09ms NumberOfSamples: 100
Semaphore.Release: 0.05ms NumberOfSamples: 100
SemaphoreSlim.WaitOne: 0.01ms NumberOfSamples: 100
SemaphoreSlim.Release: 0.01ms NumberOfSamples: 100
&lt;/code>&lt;/pre>&lt;p>As the results show, the &lt;code>SemaphoreSlim&lt;/code> class is a tiny bit quicker. After testing this myself earlier, I thought that others could run this themselves and hopefully receive a small increase in performance in their applications. The reason for the performance increase is because the &lt;code>SemaphoreSlim&lt;/code> class provides a lightweight alternative to the &lt;code>Semaphore&lt;/code> class that doesn&amp;rsquo;t use Windows kernel semaphores.&lt;/p>
&lt;p>In essence, if you do not need a named &lt;code>Semaphore&lt;/code>, use the &lt;code>SemaphoreSlim&lt;/code> class.&lt;/p></description></item></channel></rss>