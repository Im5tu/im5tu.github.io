<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>May on CodeWithStu's Blog</title><link>https://im5tu.io/article/2013/05/</link><description>Recent content in May on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2013/05/index.xml" rel="self" type="application/rss+xml"/><item><title>Using IDisposible correctly</title><link>https://im5tu.io/article/2013/05/using-idisposible-correctly/</link><pubDate>Mon, 06 May 2013 18:09:25 +0000</pubDate><guid>https://im5tu.io/article/2013/05/using-idisposible-correctly/</guid><description>&lt;p>In this article, I am going to show you how to use the &lt;code>IDisposable&lt;/code> interface correctly in your code. When I read other&amp;rsquo;s code, it is easy to pick up on subtle bugs. We need to begin to train ourselves to see the bugs and we do this by understanding what we are using. Before we begin, we need to make sure that we understand a core piece of computer science theory: Destructors.&lt;/p>
&lt;h2 id="destructors">Destructors&lt;/h2>
&lt;p>Generally speaking, destructors are the computer&amp;rsquo;s way of releasing resources from an application. In environments that contain a virtual machine with a garbage collection facility, the destructor is automatically called. In these environments, however, the destructor is also called a &lt;code>Finalizer&lt;/code>. Although these environments are &lt;del>good&lt;/del> excellent at managing memory for us, we cannot guarantee when the &lt;code>Finalizer&lt;/code> is going to be called.&lt;/p>
&lt;h2 id="enter-dispose">Enter Dispose&lt;/h2>
&lt;p>The purpose of the &lt;code>Dispose&lt;/code> is to guarantee when we are going to release resources. This might be at the end of a &lt;code>foreach&lt;/code> loop or at the end of a database connection. Either way, we have control of when we can release the resources. There are two types of resources that can be released: Managed and Unmanaged.&lt;/p>
&lt;p>Managed resources are typically objects that are run and controlled by the Common Language Runtime (CLR). Managed code supplies the metadata necessary for the CLR to provide services such as memory management and cross-language integration &lt;a href="http://stackoverflow.com/questions/334326/what-is-managed-unmanaged-code-in-c">(Source)&lt;/a>. Unmanaged resources are those outside the CLR such as Win32 APIs. These can be called from within managed code allowing some serious memory leaks if we are not careful.&lt;/p>
&lt;p>The .Net libraries have some useful interfaces in them, one of them being the &lt;code>IDisposable&lt;/code> interface. This interface has just one method called &lt;code>Dispose&lt;/code> (the name seems standard from what I have seen). Here is the implementation of the interface:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">IDisposable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When we first implement the interface in our class, we are given the following code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> : IDisposable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Release resources here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>While this implementation is fine if you don&amp;rsquo;t mind waiting for the garbage collector to come and release the resources. What if your class has a large object inside (say ~250mb). Do you really want to wait for the garbage collector? Probably not.&lt;/p>
&lt;p>In order to fix our implementation, we need to do two things. Firstly, we need to implement a &lt;code>Finalizer&lt;/code> and then implement an overload to the original &lt;code>Dispose&lt;/code> method. The reason why we implement a &lt;code>Finalizer&lt;/code> is because we want to safe-guard ourselves if we forget to call the &lt;code>Dispose&lt;/code> method. For those that do not know what a &lt;code>Finalizer&lt;/code> looks like, here it is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> : IDisposable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Constructor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ~MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Destructor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Release resources here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In order to safe-guard ourselves as I just mentioned, our &lt;code>Finalizer&lt;/code> needs to call our &lt;code>Dispose&lt;/code> method like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ~MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Destructor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dispose();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You may have realised by now that we could, potentially, call the &lt;code>Dispose&lt;/code> twice. The user will call it once followed by the CLR calling it for us in case we forget (through the &lt;code>Finalizer&lt;/code>). This gives us the requirement for the overload of the &lt;code>Dispose&lt;/code> method I mentioned earlier. If &lt;strong>we&lt;/strong> call the &lt;code>Dispose&lt;/code> method then it is &lt;em>safe&lt;/em> for us to release managed resources. However, if the &lt;strong>CLR&lt;/strong> calls the &lt;code>Dispose&lt;/code> method then we cannot safely release managed resources because we do not know their current state.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> The CLR runs on a background thread, which we have no control over. Therefore, we cannot know any objects state on that thread.&lt;/p>
&lt;p>Now that we have identified that the &lt;code>Dispose&lt;/code> method can be called from two places, we can implement this into our code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> : IDisposable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Constructor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ~MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Destructor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dispose(&lt;span style="color:#66d9ef">false&lt;/span>); &lt;span style="color:#75715e">// the CLR will call Dispose, so its an unsafe call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* The interface implementation */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dispose(&lt;span style="color:#66d9ef">true&lt;/span>); &lt;span style="color:#75715e">// WE are calling Dispose, so its a safe call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose(&lt;span style="color:#66d9ef">bool&lt;/span> safeToFreeManagedResources)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Free unmanaged resources */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (safeToFreeManagedResources)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Free managed resources */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Even though we have told the CLR that we are not to release managed resources twice, we will still release unmanaged resources twice. This is not only wasteful, but you could end up with an exception here which is something that &lt;strong>SHOULD NEVER HAPPEN&lt;/strong>. Luckily for us, the CLR has a neat way for us to tell it not to call the &lt;code>Finalizer&lt;/code> because we have already released all the resources necessary. Here is the one line magic fix:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* The interface implementation */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dispose(&lt;span style="color:#66d9ef">true&lt;/span>); &lt;span style="color:#75715e">// WE are calling Dispose, so its a safe call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GC.SuppressFinalize(&lt;span style="color:#66d9ef">this&lt;/span>); &lt;span style="color:#75715e">// WE have called dispose, there is no need to call it again Mr. GC.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="best-practise">Best Practise&lt;/h2>
&lt;p>Now that we have our code fixed, without any issues or bugs, it&amp;rsquo;s time to know a best practise. When an object implements the &lt;code>IDisposable&lt;/code> interface, we have the opportunity to use the &lt;code>using&lt;/code> statement. The idea of the &lt;code>using&lt;/code> statement is that once you have finished with the object, the CLR will call the &lt;code>Dispose&lt;/code> method for you. Note I said &lt;code>Dispose&lt;/code> not the &lt;code>Finalizer&lt;/code>. The &lt;code>using&lt;/code> statement is really easy to use:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> myClass = &lt;span style="color:#66d9ef">new&lt;/span> MyClass())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Do stuff here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the compiler sees this code, it actually expands it to this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> myClass = &lt;span style="color:#66d9ef">new&lt;/span> MyClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Do stuff here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">finally&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myClass.Dispose();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So there it is. Hopefully now you can implement &lt;code>IDisposable&lt;/code> correctly according to your needs.&lt;/p></description></item></channel></rss>