<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>July on CodeWithStu's Blog</title><link>https://im5tu.io/article/2020/07/</link><description>Recent content in July on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2020/07/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture Pathway Introduction</title><link>https://im5tu.io/article/2020/07/architecture-pathway-introduction/</link><pubDate>Wed, 15 Jul 2020 20:56:00 +0100</pubDate><guid>https://im5tu.io/article/2020/07/architecture-pathway-introduction/</guid><description>&lt;p>Over the past year or so, I&amp;rsquo;ve had the pleasure of mentoring people on their software development journeys. Some of those personnel have expressed a desire to pursue the software architect route. As it&amp;rsquo;s something that I often refer to, I&amp;rsquo;ve decided to post a mini-pathway to help guide on some of the basics.&lt;/p>
&lt;p>The majority of my learnings have come from a mixture of talented people, mistakes and good old fashion practise. The more that you practise designing systems, the better you will become, just like any other skill. I&amp;rsquo;ve included a brief summary from the pages linked so that you can glance at the content as you read along - all credits to their original authors.&lt;/p>
&lt;p>Happy Reading!&lt;/p>
&lt;h2 id="the-10-cloud-architecture-principals">The 10 Cloud Architecture Principals&lt;/h2>
&lt;h3 id="design-for-self-healinghttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesself-healing">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/self-healing">Design for self healing&lt;/a>&lt;/h3>
&lt;p>In a distributed system, failures happen. Hardware can fail. The network can have transient failures. Rarely, an entire service or region may experience a disruption, but even those must be planned for. Therefore, design an application to be self healing when failures occur.&lt;/p>
&lt;h3 id="make-all-things-redundanthttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesredundancy">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/redundancy">Make all things redundant&lt;/a>&lt;/h3>
&lt;p>A resilient application routes around failure. Identify the critical paths in your application. Is there redundancy at each point in the path? If a subsystem fails, will the application fail over to something else?&lt;/p>
&lt;h3 id="mimimize-coordinationhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesminimize-coordination">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/minimize-coordination">Mimimize coordination&lt;/a>&lt;/h3>
&lt;p>Most cloud applications consist of multiple application services — web front ends, databases, business processes, reporting and analysis, and so on. To achieve scalability and reliability, each of those services should run on multiple instances. Coordination between instances limits the benefits of horizontal scale and creates bottlenecks.&lt;/p>
&lt;h3 id="design-to-scale-outhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesscale-out">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/scale-out">Design to scale out&lt;/a>&lt;/h3>
&lt;p>A primary advantage of the cloud is elastic scaling — the ability to use as much capacity as you need, scaling out as load increases, and scaling in when the extra capacity is not needed. Design your application so that it can scale horizontally, adding or removing new instances as demand requires.&lt;/p>
&lt;h3 id="partition-around-limitshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlespartition">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/partition">Partition around limits&lt;/a>&lt;/h3>
&lt;p>In the cloud, all services have limits in their ability to scale up. Limits include number of cores, database size, query throughput, and network throughput. If your system grows sufficiently large, you may hit one or more of these limits. Use partitioning to work around these limits.&lt;/p>
&lt;h3 id="design-for-operationshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesdesign-for-operations">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-operations">Design for operations&lt;/a>&lt;/h3>
&lt;p>The cloud has dramatically changed the role of the operations team. They are no longer responsible for managing the hardware and infrastructure that hosts the application. That said, operations is still a critical part of running a successful cloud application. Involve the operations team in design and planning, to ensure the application gives them the data and insight that need to be successful.&lt;/p>
&lt;h3 id="use-managed-serviceshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesmanaged-services-">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/managed-services">Use managed services&lt;/a>&lt;/h3>
&lt;p>IaaS is like having a box of parts. You can build anything, but you have to assemble it yourself. PaaS options are easier to configure and administer. You don&amp;rsquo;t need to provision VMs, set up VNets, manage patches and updates, and all of the other overhead associated with running software on a VM.&lt;/p>
&lt;h3 id="use-the-best-data-store-for-the-jobhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesuse-the-best-data-store">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/use-the-best-data-store">Use the best data store for the job&lt;/a>&lt;/h3>
&lt;p>In any large solution, it&amp;rsquo;s likely that a single data store technology won&amp;rsquo;t fill all your needs. Alternatives to relational databases include key/value stores, document databases, search engine databases, time series databases, column family databases, and graph databases. Each has pros and cons, and different types of data fit more naturally into one or another.&lt;/p>
&lt;h3 id="design-for-evolutionhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesdesign-for-evolution">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-evolution">Design for evolution&lt;/a>&lt;/h3>
&lt;p>All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient. If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system. A change in one part of the application may break another part, or cause changes to ripple through the entire codebase. When services are designed to evolve, teams can innovate and continuously deliver new features.&lt;/p>
&lt;h3 id="build-for-the-needs-of-the-businesshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesbuild-for-business">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/build-for-business">Build for the needs of the business&lt;/a>&lt;/h3>
&lt;p>This design principle may seem obvious, but it&amp;rsquo;s crucial to keep in mind when designing a solution. Do you anticipate millions of users, or a few thousand? Is a one-hour application outage acceptable? Do you expect large bursts in traffic or a predictable workload? Ultimately, every design decision must be justified by a business requirement.&lt;/p>
&lt;h2 id="different-architecture-styles">Different Architecture Styles&lt;/h2>
&lt;h3 id="big-computehttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesbig-compute">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-compute">Big Compute&lt;/a>&lt;/h3>
&lt;p>The term big compute describes large-scale workloads that require a large number of cores, often numbering in the hundreds or thousands. Scenarios include image rendering, fluid dynamics, financial risk modeling, oil exploration, drug design, and engineering stress analysis, among others.&lt;/p>
&lt;h3 id="big-datahttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesbig-data">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-data">Big Data&lt;/a>&lt;/h3>
&lt;p>A big data architecture is designed to handle the ingestion, processing, and analysis of data that is too large or complex for traditional database systems. Big data solutions typically involve one or more of the following types of workload:&lt;/p>
&lt;ul>
&lt;li>Batch processing of big data sources at rest.&lt;/li>
&lt;li>Real-time processing of big data in motion.&lt;/li>
&lt;li>Interactive exploration of big data.&lt;/li>
&lt;li>Predictive analytics and machine learning.&lt;/li>
&lt;/ul>
&lt;h3 id="event-drivenhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesevent-driven">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven">Event Driven&lt;/a>&lt;/h3>
&lt;p>An event-driven architecture consists of event producers that generate a stream of events, and event consumers that listen for the events. Events are delivered in near real time, so consumers can respond immediately to events as they occur&lt;/p>
&lt;h3 id="microserviceshttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesmicroservices">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices">Microservices&lt;/a>&lt;/h3>
&lt;p>A microservices architecture consists of a collection of small, autonomous services. Each service is self-contained and should implement a single business capability.&lt;/p>
&lt;h3 id="n-tier-applicationhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesn-tier">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier">N-Tier Application&lt;/a>&lt;/h3>
&lt;p>An N-tier architecture divides an application into logical layers and physical tiers. Layers are a way to separate responsibilities and manage dependencies. Each layer has a specific responsibility. A higher layer can use services in a lower layer, but not the other way around.&lt;/p>
&lt;h3 id="web-queue-workerhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesweb-queue-worker">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/web-queue-worker">Web-queue-worker&lt;/a>&lt;/h3>
&lt;p>The core components of this architecture are a web front end that serves client requests, and a worker that performs resource-intensive tasks, long-running workflows, or batch jobs. The web front end communicates with the worker through a message queue.&lt;/p>
&lt;h2 id="common-design-patterns">Common Design Patterns&lt;/h2>
&lt;h3 id="anti-corruption-layerhttpsdocsmicrosoftcomen-usazurearchitecturepatternsanti-corruption-layer">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer">Anti-corruption layer&lt;/a>&lt;/h3>
&lt;p>Implement a façade or adapter layer between different subsystems that don&amp;rsquo;t share the same semantics. This layer translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an application&amp;rsquo;s design is not limited by dependencies on outside subsystems.&lt;/p>
&lt;h3 id="bulkheadhttpsdocsmicrosoftcomen-usazurearchitecturepatternsbulkhead">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead">Bulkhead&lt;/a>&lt;/h3>
&lt;p>The &lt;a href="https://im5tu.io/article/2022/02/3-ways-to-increase-app-reliability-with-polly/">Bulkhead pattern&lt;/a> is a type of application design that is tolerant of failure. In a bulkhead architecture, elements of an application are isolated into pools so that if one fails, the others will continue to function. It&amp;rsquo;s named after the sectioned partitions (bulkheads) of a ship&amp;rsquo;s hull.&lt;/p>
&lt;h3 id="cache-asidehttpsdocsmicrosoftcomen-usazurearchitecturepatternscache-aside">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">Cache-aside&lt;/a>&lt;/h3>
&lt;p>Load data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.&lt;/p>
&lt;h3 id="circuit-breakerhttpsdocsmicrosoftcomen-usazurearchitecturepatternscircuit-breaker">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">Circuit Breaker&lt;/a>&lt;/h3>
&lt;p>In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections, timeouts, or the resources being over-committed or temporarily unavailable. A circuit breaker handles faults that might take a variable amount of time to recover from, when connecting to a remote service or resource.&lt;/p>
&lt;h3 id="command--query-responsibility-segregationhttpsdocsmicrosoftcomen-usazurearchitecturepatternscqrs">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs">Command &amp;amp; Query Responsibility Segregation&lt;/a>&lt;/h3>
&lt;p>The Command and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.&lt;/p>
&lt;h3 id="compensating-transactionhttpsdocsmicrosoftcomen-usazurearchitecturepatternscompensating-transaction">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction">Compensating Transaction&lt;/a>&lt;/h3>
&lt;p>Undo the work performed by a series of steps, which together define an eventually consistent operation, if one or more of the steps fail. Operations that follow the eventual consistency model are commonly found in cloud-hosted applications that implement complex business processes and workflows.&lt;/p>
&lt;h3 id="competing-consumershttpsdocsmicrosoftcomen-usazurearchitecturepatternscompeting-consumers">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/competing-consumers">Competing Consumers&lt;/a>&lt;/h3>
&lt;p>Enable multiple concurrent consumers to process messages received on the same messaging channel. This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.&lt;/p>
&lt;h3 id="event-sourcinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsevent-sourcing">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">Event Sourcing&lt;/a>&lt;/h3>
&lt;p>Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.&lt;/p>
&lt;h3 id="gatekeeperhttpsdocsmicrosoftcomen-usazurearchitecturepatternsgatekeeper">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/gatekeeper">Gatekeeper&lt;/a>&lt;/h3>
&lt;p>Protect applications and services by using a dedicated host instance that acts as a broker between clients and the application or service, validates and sanitizes requests, and passes requests and data between them. This can provide an additional layer of security, and limit the attack surface of the system.&lt;/p>
&lt;h3 id="leader-electionhttpsdocsmicrosoftcomen-usazurearchitecturepatternsleader-election">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/leader-election">Leader Election&lt;/a>&lt;/h3>
&lt;p>Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure that instances don&amp;rsquo;t conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.&lt;/p>
&lt;h3 id="queue-based-load-levelinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsqueue-based-load-leveling">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling">Queue-Based Load Leveling&lt;/a>&lt;/h3>
&lt;p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.&lt;/p>
&lt;h3 id="retryhttpsdocsmicrosoftcomen-usazurearchitecturepatternsretry">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry">Retry&lt;/a>&lt;/h3>
&lt;p>Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation. This can improve the stability of the application.&lt;/p>
&lt;h3 id="shardinghttpsdocsmicrosoftcomen-usazurearchitecturepatternssharding">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sharding">Sharding&lt;/a>&lt;/h3>
&lt;p>Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.&lt;/p>
&lt;h3 id="sidecarhttpsdocsmicrosoftcomen-usazurearchitecturepatternssidecar">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar">Sidecar&lt;/a>&lt;/h3>
&lt;p>Deploy components of an application into a separate process or container to provide isolation and encapsulation. This pattern can also enable applications to be composed of heterogeneous components and technologies.&lt;/p>
&lt;h3 id="stranglerhttpsdocsmicrosoftcomen-usazurearchitecturepatternsstrangler">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler">Strangler&lt;/a>&lt;/h3>
&lt;p>Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system&amp;rsquo;s features, strangling the old system and allowing you to decommission it.&lt;/p>
&lt;h3 id="throttlinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsthrottling">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/throttling">Throttling&lt;/a>&lt;/h3>
&lt;p>Control the consumption of resources used by an instance of an application, an individual tenant, or an entire service. This can allow the system to continue to function and meet service level agreements, even when an increase in demand places an extreme load on resources.&lt;/p>
&lt;h2 id="distributed-systems-theory">Distributed Systems Theory&lt;/h2>
&lt;h3 id="understanding-the-8-fallacies-of-distributed-systemshttpswwwsimpleorientedarchitecturecom8-fallacies-of-distributed-systems">&lt;a href="https://www.simpleorientedarchitecture.com/8-fallacies-of-distributed-systems/">Understanding the 8 fallacies of Distributed Systems&lt;/a>&lt;/h3>
&lt;p>More than 20 years ago Peter Deutsch and James Gosling defined the 8 fallacies of distributed computing. These are false assumptions that many developers make about distributed systems. These are usually proven wrong in the long run, leading to hard to fix bugs.&lt;/p>
&lt;h3 id="cap-theoremhttpsrobertgreinercomcap-theorem-revisited">&lt;a href="https://robertgreiner.com/cap-theorem-revisited/">CAP Theorem&lt;/a>&lt;/h3>
&lt;p>The CAP Theorem states that, in a distributed system (a collection of interconnected nodes that share data.), you can only have two out of the following three guarantees across a write/read pair: Consistency, Availability, and Partition Tolerance - one of them must be sacrificed.&lt;/p>
&lt;h3 id="how-sharding-workshttpsmediumcomjeeyoungkhow-sharding-works-b4dec46b3f6">&lt;a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">How Sharding Works&lt;/a>&lt;/h3>
&lt;p>Your application suddenly becomes popular. Traffic and data is starting to grow, and your database gets more overloaded every day. People on the internet tell you to scale your database by sharding, but you don’t really know what it means. You start doing some research, and run into this post.&lt;/p>
&lt;h3 id="consistent-hashinghttpwwwtom-e-whitecom200711consistent-hashinghtml">&lt;a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html">Consistent Hashing&lt;/a>&lt;/h3>
&lt;p>The need for consistent hashing arose from limitations experienced while running collections of caching machines - web caches, for example. If you have a collection of n cache machines then a common way of load balancing across them is to put object o in cache machine number hash(o) mod n.&lt;/p>
&lt;h2 id="other-interesting-reads">Other Interesting Reads&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/">Workload Isolation Using Shuffle-Sharding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/avoiding-insurmountable-queue-backlogs/">Avoiding Insurmountable Queue Backlogs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/implementing-health-checks/">Implementing Health Checks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@SkyscannerEng/monoliths-and-microservices-8c65708c3dbf">Monoliths and Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a">Fault Tolerance in a High Volume, Distributed System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@NetflixTechBlog/tips-for-high-availability-be0472f2599c">Tips for High Availability&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://technology.riotgames.com/news/globalizing-player-accounts">Globalizing Player Accounts while Maintaining Availability&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f">Microservice Architecture at Medium&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://architecht.io/lessons-from-facebook-on-engineering-for-scale-f5716f0afc7a">Automate and abstract: Lessons from Facebook on engineering for scale&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>My Favourite Git Aliases</title><link>https://im5tu.io/article/2020/07/my-favourite-git-aliases/</link><pubDate>Sat, 11 Jul 2020 12:56:00 +0100</pubDate><guid>https://im5tu.io/article/2020/07/my-favourite-git-aliases/</guid><description>&lt;p>Git aliases are used to create new git commands that can either invoke a function, or be used to create commands that map to longer commands. For example, we could map &lt;code>git co&lt;/code> to &lt;code>git checkout&lt;/code> or have &lt;code>git undo&lt;/code> undo our previous commit. In this article, I&amp;rsquo;m going to show you some of my favourite git aliases.&lt;/p>
&lt;h2 id="creating-a-new-git-alias">Creating a new git alias&lt;/h2>
&lt;p>We have two ways of creating git aliases: via the command line or directly in the &lt;code>.gitconfig&lt;/code> file. You only need to use one of the approaches, so pick which best works for you.&lt;/p>
&lt;p>From the command line, the format is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> git config alias.&amp;lt;name&amp;gt; &amp;lt;command&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note: &lt;em>You can also add these globally by using &lt;code>git config --global alias.&amp;lt;name&amp;gt; &amp;lt;command&amp;gt;&lt;/code>.&lt;/em>&lt;/p>
&lt;p>If you are manually editing a &lt;code>.gitconfig&lt;/code> file, you need to find/create a section called &lt;code>[alias]&lt;/code>. Then the format is &lt;code>&amp;lt;name&amp;gt; = command&lt;/code>, like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">&amp;lt;name&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;lt;command&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-undo">git undo&lt;/h2>
&lt;p>&lt;code>git undo&lt;/code> is for those times that you realise that you&amp;rsquo;ve messed up the commit and haven&amp;rsquo;t pushed it to your remote yet. My common use case is because my muscle memory keeps writing &lt;code>git commit -am&lt;/code> instead of &lt;code>git commit -m&lt;/code>. This command undoes the last commit so that you can recommit however you see fit.&lt;/p>
&lt;p>To add this alias from the command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global alias.undo reset HEAD~1 --mixed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or directly in the &lt;code>.gitconfig&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">undo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">reset HEAD~1 --mixed&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-reset-author">git reset-author&lt;/h2>
&lt;p>Like I imagine a lot of people do, I run multiple git profiles on my machine. One for personal work and one for work. Occasionally, I mess up which profile I am using so I want to reset the commit author details. To do this, I run &lt;code>git reset-author&lt;/code>. This does not make any other changes to the commit other than the author.&lt;/p>
&lt;p>To add this alias from the command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global alias.reset-author commit --amend --reset-author --no-edit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or directly in the &lt;code>.gitconfig&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reset-author&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">commit --amend --reset-author --no-edit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-sync">git sync&lt;/h2>
&lt;p>When working on different machines, or working with another person on the same branch, you may need to update your local branch to be inline with the remote branch. &lt;code>git sync&lt;/code> does this for us by fetching, pulling then pushing our working branch. This command uses a function to run multiple git commands in one. To make your own custom function, the syntax is &lt;code>!f() { &amp;lt;YOUR COMMANDS HERE&amp;gt;; };f&lt;/code>.&lt;/p>
&lt;p>To add this alias from the command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global alias.sync &lt;span style="color:#e6db74">&amp;#34;!f() { git fetch --tags &amp;amp;&amp;amp; git pull &amp;amp;&amp;amp; git push; };f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or directly in the &lt;code>.gitconfig&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sync&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!f() { git fetch --tags &amp;amp;&amp;amp; git pull &amp;amp;&amp;amp; git push; };f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-refresh">git refresh&lt;/h2>
&lt;p>Much like the aforementioned &lt;code>git sync&lt;/code>, &lt;code>git refresh&lt;/code> also brings a branch up to date but with a different branch. This is useful for updating say &lt;code>task/my-task&lt;/code> with the latest version of &lt;code>main&lt;/code>. To run the alias, the syntax is &lt;code>git refresh &amp;lt;current branch&amp;gt; &amp;lt;base branch&amp;gt;&lt;/code>.&lt;/p>
&lt;p>To add this alias from the command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global alias.refresh &lt;span style="color:#e6db74">&amp;#34;!f() { git switch &lt;/span>$2&lt;span style="color:#e6db74"> &amp;amp;&amp;amp; git fetch &amp;amp;&amp;amp; git pull &amp;amp;&amp;amp; git switch &lt;/span>$1&lt;span style="color:#e6db74"> &amp;amp;&amp;amp; git merge &lt;/span>$2&lt;span style="color:#e6db74">; };f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or directly in the &lt;code>.gitconfig&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">refresh&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;!f() { git switch $2 &amp;amp;&amp;amp; git fetch &amp;amp;&amp;amp; git pull &amp;amp;&amp;amp; git switch $1 &amp;amp;&amp;amp; git merge $2; };f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-history">git history&lt;/h2>
&lt;p>On occasion I need to view the current status of my remote branch to see the names of the recent commits. Enter &lt;code>git history&lt;/code> which provides you with a list of commits on a single, eg:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 967c867 (HEAD -&amp;gt; dev, origin/dev, origin/HEAD) HighCPU fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 824a02b Fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 285a98a Bugfix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* fbf9d43 Cleanup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 01f5275 Minor updates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 9725077 Added sqs dispatcher code to sample&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* e9326d7 Added dispatch metrics, small perf improvements&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 4ec2ff0 Performance improvements&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 903db9f Allowed SQS to be unbounded locally&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* d8ff987 Version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* afbd67d Bug fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* b912c54 Updated batching&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 1ab32db Version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 4a5203e Fixed assembly lookup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 7f7cd19 Guess what, packages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 4a43ef7 Batched SQS Dispatcher. Configurable JSON Options. (#202)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* fa745d4 Nullable Reference Types&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 28aa04a Package update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* e435497 Fix typo in OpenMessage.Serializtion (#256)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 1cc730c Updated packages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* d2991da Addresses #232,# 227, #237 (#238)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">* 3893833 Updated packages&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To add this alias from the command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global alias.history log --oneline --graph
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or directly in the &lt;code>.gitconfig&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">[alias]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">history&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">log --oneline --graph&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s it. Hopefully these little alias are useful in your workflows. Let me know on &lt;a href="https://twitter.com/im5tu">Twitter&lt;/a> if you have more that you want to share.&lt;/p>
&lt;p>Happy aliasing!&lt;/p></description></item></channel></rss>