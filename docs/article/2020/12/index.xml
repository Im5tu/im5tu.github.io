<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>December on CodeWithStu's Blog</title><link>https://im5tu.io/article/2020/12/</link><description>Recent content in December on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2020/12/index.xml" rel="self" type="application/rss+xml"/><item><title>Blending Metrics Using EventCounters In C#</title><link>https://im5tu.io/article/2020/12/blending-metrics-using-eventcounters-in-c/</link><pubDate>Sun, 27 Dec 2020 12:53:17 +0000</pubDate><guid>https://im5tu.io/article/2020/12/blending-metrics-using-eventcounters-in-c/</guid><description>&lt;p>In a world where we use auto-scaling a lot, its often not just one metric that we will take into consideration when deciding whether or not to scale our applications. For example, we might have a combination of CPU usage, memory usage and web request latency. Some services like AWS CloudWatch Metrics only allow scaling based off a single value. Luckily, we can blend metrics together to create new ones, which we can then use in our scaling policies. A blended metric is made up of however one or more existing metrics that you choose, called aspects, and can be published as if it were any other metric, eg: publish to DataDog/Cloudwatch.&lt;/p>
&lt;p>Each aspect contains the following:&lt;/p>
&lt;ul>
&lt;li>Name: This is the name of the metric that you wish to track&lt;/li>
&lt;li>Minimum: This indicates the lower bounds of the metric, which if breached will be kept at this value&lt;/li>
&lt;li>Maximum: This indicates the upper bounds of the metric, which if breached will be kept at this value&lt;/li>
&lt;li>Weighting: This increases the impact of this metric on the overall score, useful for when one metric impacts more than another&lt;/li>
&lt;/ul>
&lt;h2 id="value-calculation">Value Calculation&lt;/h2>
&lt;p>In essence there are four points to the calculation:&lt;/p>
&lt;ol>
&lt;li>Get the value limited by the minimum and maximum bounds&lt;/li>
&lt;li>Get the value as a fraction of the maximum value&lt;/li>
&lt;li>Apply the weight to the fractional value&lt;/li>
&lt;li>Average all aspect values together to get the final score&lt;/li>
&lt;/ol>
&lt;p>Let&amp;rsquo;s walk through how this works in reality. Assume we have the following configuration:&lt;/p>
&lt;ul>
&lt;li>Aspect 1: Minimum=0, Maximum=100, Weighting=0, Value=50&lt;/li>
&lt;li>Aspect 2: Minimum=0, Maximum=100, Weighting=1, Value=50&lt;/li>
&lt;/ul>
&lt;p>For step 1, we need to check whether the value supplied is between the specified minimum and maximum. For this example, it is, but if the value was greater than the maximum (eg: 150), the value would be set to 100 (the maximum value allowed). The same logic applies inversely for the minimum value.&lt;/p>
&lt;p>For step 2, we take the value and divide it by the maximum allowed value. This returns us a value between 0 &amp;amp; 1 - in our case, it&amp;rsquo;s &lt;code>0.5&lt;/code> for both aspects.&lt;/p>
&lt;p>As we now know that step 2 returns the value &lt;code>0.5&lt;/code> in both aspects, we can add the weighting value: &lt;code>value = value * (1 + weighting)&lt;/code>. For aspect 1, we would end up with the calculation &lt;code>value = 0.5 x 1 = 0.5&lt;/code>. Whereas for aspect 2, we would end up with the calculation &lt;code>value = 0.5 x 2 = 1&lt;/code>.&lt;/p>
&lt;p>For the last step, we calculate the average of the values with their weights applied, eg: &lt;code>(0.5 + 1) / 2 = 0.75&lt;/code>. &lt;code>0.75&lt;/code> is the value that will be reported for the metric.&lt;/p>
&lt;p>&lt;em>&lt;strong>Note:&lt;/strong> An aspect&amp;rsquo;s weighting must be between 0 and 1.&lt;/em>&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>The implementation I am about to show builds upon my previous work with &lt;a href="http://localhost:1313/series/diagnostics-in-.net-core-3/">EventCounters&lt;/a> and &lt;a href="https://im5tu.io/article/2020/12/publish-metrics-to-cloudwatch-in-.net-core/">Publishing to CloudWatch&lt;/a>, which I would encourage you to read. First, let&amp;rsquo;s take a look at the &lt;code>SimpleMetricObserver&lt;/code> class, which is a simple helper class that saves some of the boilerplate for the observable pattern:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SimpleMetricObserver&lt;/span> : IObserver&amp;lt;MetricUpdate&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;inheritDoc /&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnCompleted() { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;inheritDoc /&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnError(Exception error) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;inheritDoc /&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnNext(MetricUpdate &lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, we can take a look at the implementation of &lt;code>BlendedMetricObserver&lt;/code>. This observer is designed to listen to a series of metrics from the published metric stream I created in the &lt;a href="https://im5tu.io/article/2020/12/publish-metrics-to-cloudwatch-in-.net-core/">CloudWatch article&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BlendedMetricObserver&lt;/span> : SimpleMetricObserver, IDisposable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> IOptionsMonitor&amp;lt;BlendedMetricOptions&amp;gt; _blendedMetricOptionsMonitor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> Dictionary&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, BlendedMetricAspect&amp;gt; _aspects = &lt;span style="color:#66d9ef">new&lt;/span> Dictionary&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, BlendedMetricAspect&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> Dictionary&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span>&amp;gt; _values = &lt;span style="color:#66d9ef">new&lt;/span> Dictionary&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span>&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> List&amp;lt;IDisposable&amp;gt; _disposables = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;IDisposable&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> PollingCounter? _counter = &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> BlendedMetricObserver(&lt;span style="color:#66d9ef">string&lt;/span> name, IOptionsMonitor&amp;lt;BlendedMetricOptions&amp;gt; blendedMetricOptionsMonitor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _name = name ?? &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentNullException(nameof(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _blendedMetricOptionsMonitor = blendedMetricOptionsMonitor ?? &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentNullException(nameof(blendedMetricOptionsMonitor));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _disposables.Add(_blendedMetricOptionsMonitor.OnChange(options =&amp;gt; UpdateSettings(options)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UpdateSettings(_blendedMetricOptionsMonitor.Get(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnNext(MetricUpdate &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_values)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!_aspects.TryGetValue(&lt;span style="color:#66d9ef">value&lt;/span>.Name, &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> aspect))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> filters = aspect.TagFilters.ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (filters.Count == &lt;span style="color:#ae81ff">0&lt;/span> || filters.All(x =&amp;gt; &lt;span style="color:#66d9ef">value&lt;/span>.Tags.Contains(x, TagFilterComparer.Instance)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _values[&lt;span style="color:#66d9ef">value&lt;/span>.Name] = ConvertToWeightedValue(aspect, &lt;span style="color:#66d9ef">value&lt;/span>.Value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Exposed as protected so that we have at least some way of testing this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> GetCurrentValue()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_values)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_values.Count == &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Calculate the average of whether or not we should scale based on the weighted value of each metric&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// perf: do not use linq for this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> total = &lt;span style="color:#ae81ff">0d&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> entry &lt;span style="color:#66d9ef">in&lt;/span> _values)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total += entry.Value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> total / _values.Count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> ConvertToWeightedValue(BlendedMetricAspect aspect, &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Get the value or the lower/upper boundary, where applicable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = Math.Min(Math.Max(aspect.Minimum, &lt;span style="color:#66d9ef">value&lt;/span>), aspect.Maximum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// work out the value as a fraction of the maximum value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> /= aspect.Maximum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Add the weighting to the value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> *= (&lt;span style="color:#ae81ff">1&lt;/span> + aspect.Weighting);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Return the value bounded by 0 and 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.Min(Math.Max(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">value&lt;/span>), &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> UpdateSettings(BlendedMetricOptions options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#66d9ef">string&lt;/span>.Equals(options.MetricName, _name))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_values)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _aspects.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _values.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_counter &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _counter = &lt;span style="color:#66d9ef">new&lt;/span> PollingCounter(_name, MyEventSource.Instance, () =&amp;gt; GetCurrentValue());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> ((&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span> options.Tags)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _counter.AddMetadata(key, &lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> aspect &lt;span style="color:#66d9ef">in&lt;/span> options.Aspects)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrWhiteSpace(aspect.Name))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _aspects[aspect.Name] = aspect;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> disposable &lt;span style="color:#66d9ef">in&lt;/span> _disposables)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> disposable.Dispose();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _disposables.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _values.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _aspects.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TagFilterComparer&lt;/span> : IEqualityComparer&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> TagFilterComparer Instance = &lt;span style="color:#66d9ef">new&lt;/span> TagFilterComparer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> Equals(KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; x, KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>.Equals(x.Key, y.Key, StringComparison.Ordinal) &amp;amp;&amp;amp; &lt;span style="color:#66d9ef">string&lt;/span>.Equals(x.Value, y.Value, StringComparison.Ordinal);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> GetHashCode(KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; obj)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> HashCode.Combine(obj.Key, obj.Value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s break down some of the core methods. Firstly, the &lt;code>OnNext&lt;/code> method is probably one of the most important ones as it listens to the incoming stream of metric data that is being published from our application, filtering for only the information that makes up our blended metric, before storing its value so that we can use it in the calculation portion. One thing to note in here as well, is that we can filter metrics by specific tags as well in our configuration. This means that we can re-use the same name and vary the metric by tags, much like we did in the &lt;a href="https://im5tu.io/article/2020/06/diagnostics-in-.net-core-3-listening-to-outbound-http-requests/">Capturing HTTP requests article&lt;/a>. This is where the &lt;code>TagFilterComparer&lt;/code> comes in handy, helping to determine equality in metric tags.&lt;/p>
&lt;p>The &lt;code>ConvertToWeightedValue&lt;/code> method takes the latest stored values of each of the aspects that make up the blended metric and performs the value calculation as described earlier in the article. This method is called periodically, depending on interval set by the &lt;code>EnableEvents&lt;/code> call on the EventSource that we are registering the blended metric against. You can see how to do that &lt;a href="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/#detecting-eventsources">here&lt;/a>.&lt;/p>
&lt;p>Lastly, the &lt;code>UpdateSettings&lt;/code> method is responsible for (re)creating the polling counter which will refresh on the specified interval that has been setup on the EventSource (eg: every second). Whilst&lt;/p>
&lt;h3 id="options--validation">Options &amp;amp; Validation&lt;/h3>
&lt;p>As you may have seen above, we have a specific options class that we use to track the different options of the blended metric:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;Represents a metric that is made up of one or more metrics&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BlendedMetricOptions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The name to send the metric through as&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string?&lt;/span> MetricName { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;A collection of metrics that make up the blended metric&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IEnumerable&amp;lt;BlendedMetricAspect&amp;gt; Aspects { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; } = Enumerable.Empty&amp;lt;BlendedMetricAspect&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The tags that should be applied to the blended metric&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt; Tags { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; } = Enumerable.Empty&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;Represents a part that makes up the blended metric&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BlendedMetricAspect&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The full name of the metric&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string?&lt;/span> Name { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The lower limit of the metric. If the value is less than this value, it is set to this value.&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> Minimum { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; } = &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The upper limit of the metric. If the value is greater than this value, it is set to this value.&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> Maximum { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; } = &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;The weighting that&amp;#39;s applied to the metric&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> Weighting { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; } = &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;Filters a metric where the specified tags are present&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt; TagFilters = Enumerable.Empty&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> BlendedMetricAspect()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> BlendedMetricAspect(&lt;span style="color:#66d9ef">string&lt;/span> name, &lt;span style="color:#66d9ef">double&lt;/span> minimum = &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span> maximum = &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span> weighting = &lt;span style="color:#ae81ff">0&lt;/span>, IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;? tagFilters = &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name = name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Minimum = minimum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Maximum = maximum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Weighting = weighting;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TagFilters = tagFilters ?? Enumerable.Empty&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;Factory function for creating a new instance&amp;lt;/summary&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> BlendedMetricAspect Create(&lt;span style="color:#66d9ef">string&lt;/span> name, &lt;span style="color:#66d9ef">double&lt;/span> minimum = &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span> maximum = &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span> weighting = &lt;span style="color:#ae81ff">0&lt;/span>, IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;? tagFilters = &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> =&amp;gt; &lt;span style="color:#66d9ef">new&lt;/span> BlendedMetricAspect(name, minimum, maximum, weighting, tagFilters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For completeness, I&amp;rsquo;ve included a simple options validator to ensure that we stick within some of the basic rules that we described earlier. This validation is bound to our IoC container in the next section.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BlendedMetricOptionsValidation&lt;/span> : IValidateOptions&amp;lt;BlendedMetricOptions&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ValidateOptionsResult Validate(&lt;span style="color:#66d9ef">string&lt;/span> name, BlendedMetricOptions options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> failures = Validate(options.Aspects);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> failures.Count &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span> ? ValidateOptionsResult.Fail(failures) : ValidateOptionsResult.Success;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> List&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; Validate(IEnumerable&amp;lt;BlendedMetricAspect&amp;gt; aspects)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> failures = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> aspectLst = aspects.ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> aspect &lt;span style="color:#66d9ef">in&lt;/span> aspectLst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrWhiteSpace(aspect.Name))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failures.Add(&lt;span style="color:#e6db74">$&amp;#34;{nameof(BlendedMetricAspect.Name)} cannot be null, empty or whitespace. Index: {aspectLst.IndexOf(aspect)}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (aspect.Minimum &amp;gt;= aspect.Maximum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failures.Add(&lt;span style="color:#e6db74">$&amp;#34;Aspect: {aspect.Name} - {nameof(BlendedMetricAspect.Minimum)} (Current: {aspect.Minimum}) must be less than {nameof(BlendedMetricAspect.Maximum)} (Current: {aspect.Maximum}).&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (aspect.Weighting &amp;lt; &lt;span style="color:#ae81ff">0&lt;/span> || aspect.Weighting &amp;gt; &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failures.Add(&lt;span style="color:#e6db74">$&amp;#34;Aspect: {aspect.Name} - {nameof(BlendedMetricAspect.Weighting)} must be between 0 &amp;amp; 1. Current: {aspect.Weighting}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> failures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="extensions">Extensions&lt;/h3>
&lt;p>The last part of our implementation is to add some helpful &lt;a href="https://im5tu.io/article/2012/12/extension-methods-in-dotnet/">extension methods&lt;/a> for configuring new blended metrics in our IoC containers. These methods bind the necessary components and allow you to configure one or more blended metrics either from configuration or from passing the information into the method:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> IServiceCollection AddBlendedMetrics(&lt;span style="color:#66d9ef">this&lt;/span> IServiceCollection services, IConfigurationSection configurationSection)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> section &lt;span style="color:#66d9ef">in&lt;/span> configurationSection.GetChildren())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> services.AddBlendedMetric(section.Key, options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.MetricName = section.Key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configurationSection.Bind(options);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> services;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> IServiceCollection AddBlendedMetric(&lt;span style="color:#66d9ef">this&lt;/span> IServiceCollection services, &lt;span style="color:#66d9ef">string&lt;/span> name, Action&amp;lt;BlendedMetricOptions&amp;gt; configurationAction)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrWhiteSpace(name))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentNullException(nameof(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = name.ToLowerInvariant().Replace(&lt;span style="color:#e6db74">&amp;#34;_&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>).Replace(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> services.TryAddSingleton&amp;lt;IValidateOptions&amp;lt;BlendedMetricOptions&amp;gt;, BlendedMetricOptionsValidation&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> services.AddSingleton&amp;lt;IObserver&amp;lt;MetricUpdate&amp;gt;&amp;gt;(sp =&amp;gt; ActivatorUtilities.CreateInstance&amp;lt;BlendedMetricObserver&amp;gt;(sp, name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> services.Configure&amp;lt;BlendedMetricOptions&amp;gt;(name, configurationAction);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> IServiceCollection AddBlendedMetric(&lt;span style="color:#66d9ef">this&lt;/span> IServiceCollection services, &lt;span style="color:#66d9ef">string&lt;/span> name, Func&amp;lt;IEnumerable&amp;lt;BlendedMetricAspect&amp;gt;&amp;gt; aspects, IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt;? dimensions = &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> services.AddBlendedMetric(name, options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.MetricName = name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.Aspects = options.Aspects.Concat(aspects()).ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dimensions &lt;span style="color:#66d9ef">is&lt;/span> {})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.Tags = dimensions.ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That pretty much wraps up our basic implementation of blended metrics. With the complete implementation, we should have our metrics published to our provider of choice. I hope you can see how useful they can be when combined with things like auto-scaling. Enjoy!&lt;/p></description></item><item><title>Publish Metrics to Cloudwatch in .NET Core</title><link>https://im5tu.io/article/2020/12/publish-metrics-to-cloudwatch-in-.net-core/</link><pubDate>Sun, 13 Dec 2020 16:21:58 +0000</pubDate><guid>https://im5tu.io/article/2020/12/publish-metrics-to-cloudwatch-in-.net-core/</guid><description>&lt;p>In a &lt;a href="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/">previous post&lt;/a> I took a look at how we can utilize .NET event counters to record metrics in our applications. However, I never covered the implementation of how I write the metrics to either CloudWatch or DataDog. In this article, I&amp;rsquo;m going to take a look at how to publish metrics to CloudWatch and one way of integrating it with the aforementioned blog series.&lt;/p>
&lt;h2 id="what-is-cloudwatch">What is CloudWatch?&lt;/h2>
&lt;p>Amazon CloudWatch is a monitoring and observability service that provides you with data and actionable insights to monitor your applications, respond to system-wide performance changes, optimize resource utilization, and get a unified view of operational health. CloudWatch collects monitoring and operational data in the form of logs, metrics, and events, providing you with a unified view of AWS resources, applications, and services that run on AWS and on-premises servers. You can use CloudWatch to detect anomalous behaviour in your environments, set alarms, visualize logs and metrics side by side, take automated actions, troubleshoot issues, and discover insights to keep your applications
running smoothly. &lt;em>(&lt;a href="https://aws.amazon.com/cloudwatch/">Source&lt;/a>)&lt;/em>&lt;/p>
&lt;h2 id="writing-a-cloudwatch-metric-publisher">Writing a CloudWatch Metric Publisher&lt;/h2>
&lt;p>If you&amp;rsquo;ve been following the previous articles, you would have seen that I omitted the type that I personally use to pass the metric information to the publishers. The common metric update type I&amp;rsquo;ve been using contains the name of the metric, it&amp;rsquo;s value and any tags/dimensions that you which to be attached to the metric. For completeness, and incase you haven&amp;rsquo;t been following the previous articles, here is the &lt;code>MetricUpdate&lt;/code> type that we will reference:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[DebuggerDisplay(&amp;#34;{ToString(),nq}&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MetricUpdate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>,&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt; Tags;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">float&lt;/span> Value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MetricUpdate(&lt;span style="color:#66d9ef">string&lt;/span> name, &lt;span style="color:#66d9ef">float&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>, IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>,&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt; tags)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name = name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Value = &lt;span style="color:#66d9ef">value&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Tags = tags;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> ToString() =&amp;gt; &lt;span style="color:#e6db74">$&amp;#34;{Name}:{Value} ({string.Join(&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;, Tags.Select(x =&amp;gt; $&amp;#34;&lt;/span>{x.Key}={x.Value}&lt;span style="color:#e6db74">&amp;#34;))})&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we have this type configured, we need to install the &lt;code>AWSSDK.CloudWatch&lt;/code> NuGet package, which will allow us to communicate with AWS CloudWatch. Our entry point to publishing the metrics will be a simple interface that will enable us to swap out the implementation for testing at a later point:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ICloudWatchMetricsPublisher&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Task PublishMetricsAsync(IEnumerable&amp;lt;MetricUpdate&amp;gt; metrics);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will also need to have a corresponding implementation for the &lt;code>ICloudWatchMetricsPublisher&lt;/code> contract:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CloudWatchMetricsPublisher&lt;/span> : ICloudWatchMetricsPublisher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ILogger&amp;lt;CloudWatchMetricsPublisher&amp;gt; _logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CloudWatchMetricsPublisher(ILogger&amp;lt;CloudWatchMetricsPublisher&amp;gt; logger)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _logger = logger ?? &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentNullException(nameof(logger));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task PublishMetricsAsync(IEnumerable&amp;lt;MetricUpdate&amp;gt; metrics)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> var client = CreateClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> datums = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;MetricDatum&amp;gt;(metrics.Select(ConvertToDatum));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> request = &lt;span style="color:#66d9ef">new&lt;/span> PutMetricDataRequest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Namespace = &lt;span style="color:#e6db74">&amp;#34;MyCustomNamespace&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetricData = datums
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> client.PutMetricDataAsync(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> AmazonCloudWatchClient CreateClient() =&amp;gt; &lt;span style="color:#66d9ef">new&lt;/span> AmazonCloudWatchClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Other methods, defined below&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Our main steps in the code above are:&lt;/p>
&lt;ol>
&lt;li>Create a new instance of the &lt;code>AmazonCloudWatchClient&lt;/code> class which allows us to communicate with CloudWatch&lt;/li>
&lt;li>Convert our &lt;code>MetricUpdate&lt;/code> type into the AWS specific &lt;code>MetricDatum&lt;/code> type&lt;/li>
&lt;li>Create a new instance of &lt;code>PutMetricDataRequest&lt;/code> and call &lt;code>PutMetricDataAsync&lt;/code> on the AWS Client, which sends the metrics through to CloudWatch, assuming we have the correct permissions&lt;/li>
&lt;/ol>
&lt;p>When we convert our &lt;code>MetricUpdate&lt;/code> to a &lt;code>MetricDatum&lt;/code>, there are a few points that we need to consider, including:&lt;/p>
&lt;ul>
&lt;li>The unit type that we want to be represented for the metric in CloudWatch&lt;/li>
&lt;li>The storage resolution that we want to use&lt;/li>
&lt;li>The number of dimensions that we can use for the metric&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;ve wrapped up some of this logic into a &lt;code>ConvertToDatum&lt;/code> method to keep the logic contained and the main publishing code clear:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> MetricDatum ConvertToDatum(&lt;span style="color:#66d9ef">in&lt;/span> MetricUpdate metric)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MetricDatum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimestampUtc = DateTime.UtcNow,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetricName = metric.Name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Value = metric.Value,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Unit = GetUnitMapping(metric),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StorageResolution = &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dimensions = FormatDimensions(metric.Tags)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The most important point part about the code snippet above is the &lt;code>StorageResolution&lt;/code>. Setting this to 1 specifies this metric as a high-resolution metric, so that CloudWatch stores the metric with sub-minute resolution down to one second. Setting this to 60 specifies this metric as a regular-resolution metric, which CloudWatch stores at 1-minute resolution. For more information about high-resolution metrics, see &lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#high-resolution-metrics">High-Resolution Metrics&lt;/a> in the Amazon CloudWatch User Guide.&lt;/p>
&lt;p>Otherwise, for clarity and future extensibility, I&amp;rsquo;ve separated the unit mapping and the dimensions formatting. Lastly, should you want to change the timestamp, you just need to update the &lt;code>MetricUpdate&lt;/code> type to add the TimeStamp. This could be handy for retries or delays in publication, but that&amp;rsquo;s out of scope for this article. Now, lets take a look at the unit mapping code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> StandardUnit GetUnitMapping(&lt;span style="color:#66d9ef">in&lt;/span> MetricUpdate metric)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;latency&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.Milliseconds;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;count&amp;#34;&lt;/span>) || metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;length&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.Count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;usage&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.Percent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;size&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.Bytes;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (metric.Name.EndsWith(&lt;span style="color:#e6db74">&amp;#34;rate&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.CountSecond;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StandardUnit.None;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There&amp;rsquo;s nothing really special going on here, we just use the ending of the metric to decide what . In my real production code, this is configurable should we need to explicitly set something, but i&amp;rsquo;ll leave that as an exercise for you dearest reader.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> List&amp;lt;Dimension&amp;gt; FormatDimensions(IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;&amp;gt; dimensions)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;Dimension&amp;gt;(&lt;span style="color:#ae81ff">10&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> dimension &lt;span style="color:#66d9ef">in&lt;/span> dimensions)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.Add(&lt;span style="color:#66d9ef">new&lt;/span> Dimension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name = dimension.Key,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Value = dimension.Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We can only support a maximum of 10 dimensions in cloudwatch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result.Count == &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _logger.LogWarning(&lt;span style="color:#e6db74">&amp;#34;Cloudwatch only supports 10 dimensions per metric. Any additional dimensions have been removed.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Again, there is nothing really special going on with the formatting of the dimensions. It is important to note that only the first 10 elements of the collection will be passed through to CloudWatch. This is a limitation on the CloudWatch side and as such, we log a warning to know when we&amp;rsquo;ve hit that limit, allowing us to act on it in the future should we need to. As far as the publishing is concerned, that&amp;rsquo;s pretty much it.&lt;/p>
&lt;p>&lt;em>As you may have noticed from the snippets of code, I have left out a lot of the configuration that would normally be done as I didn&amp;rsquo;t want to bloat the code with unnecessary code, allowing you to get the important bits.&lt;/em>&lt;/p>
&lt;h2 id="integrating-our-cloudwatch-publisher-with-net-event-counters">Integrating our CloudWatch publisher with .NET Event Counters&lt;/h2>
&lt;p>In a &lt;a href="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/">previous post&lt;/a> I received a comment asking how I hook up .NET EventCounters with either DataDog or CloudWatch. The short answer is that I use the above code, at least a variation of it, to publish directly to CloudWatch. The longer answer is that I have an extensible mechanism which allows me to publish to one or more sources at once, depending on my needs. To do this, we need multiple parts to complete the puzzle:&lt;/p>
&lt;ol>
&lt;li>An observable which we can publish the metric updates to&lt;/li>
&lt;li>An observer per publisher (eg: CloudWatch/DataDog)&lt;/li>
&lt;li>The publishing code (like the former part of this article)&lt;/li>
&lt;li>Link the .NET EventCounters collectors to the observable&lt;/li>
&lt;/ol>
&lt;h3 id="creating-the-observable-infrastructure">Creating the observable infrastructure&lt;/h3>
&lt;p>The first part of linking .NET event counters to our new publishers, is to create an implementation of the observable pattern for which .NET has two handy interfaces that we can use:&lt;/p>
&lt;ul>
&lt;li>&lt;code>IObservable&amp;lt;T&amp;gt;&lt;/code> - which allows us to subscribe to a stream of events that are emitted by an object&lt;/li>
&lt;li>&lt;code>IObserver&amp;lt;T&amp;gt;&lt;/code> - which can be added to the above observable via the &lt;code>Subscribe&lt;/code> method. The instance that&amp;rsquo;s subscribed will receive notifications for: each object in the stream, exceptions from the stream and completion of the stream.&lt;/li>
&lt;/ul>
&lt;p>As the &lt;code>IObservable&amp;lt;T&amp;gt;&lt;/code> interface isn&amp;rsquo;t concerned with how the data is retrieved from the stream, as it could be from a network stream or an in-memory stream for example, we will need a way of publishing the data. To do this, we will add the &lt;code>WriteMetric&lt;/code> method to a custom interface so that we can implement the pattern properly:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">IMetricsObservable&lt;/span> : IObservable&amp;lt;MetricUpdate&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> WriteMetric(&lt;span style="color:#66d9ef">ref&lt;/span> MetricUpdate metricUpdate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MetricsObservable&lt;/span> : IMetricsObservable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> List&amp;lt;IObserver&amp;lt;MetricUpdate&amp;gt;&amp;gt; _observers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MetricsObservable(IEnumerable&amp;lt;IObserver&amp;lt;MetricUpdate&amp;gt;&amp;gt; observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _observers = observers.ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IDisposable Subscribe(IObserver&amp;lt;MetricUpdate&amp;gt; observer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _observers.Add(observer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ActOnDispose(() =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _observers.Remove(observer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> WriteMetric(&lt;span style="color:#66d9ef">ref&lt;/span> MetricUpdate metricUpdate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span>(_observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> observer &lt;span style="color:#66d9ef">in&lt;/span> _observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observer.OnNext(metricUpdate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lock&lt;/span> (_observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> observer &lt;span style="color:#66d9ef">in&lt;/span> _observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observer.OnCompleted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _observers.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ActOnDispose&lt;/span> : IDisposable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> Action _act;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> _disposed = &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ActOnDispose(Action act)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _act = act;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_disposed)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _disposed = &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _act();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The code above is a basic implementation of the observable pattern, which also takes a series of known consumers from an IoC container should it be configured. We return a custom disposable from the &lt;code>Subscribe&lt;/code> method, that when disposed, will remove the &lt;code>IObserver&amp;lt;T&amp;gt;&lt;/code> instance from the list of known consumers.&lt;/p>
&lt;p>The next part of the puzzle is to create our &lt;code>IObserver&amp;lt;T&amp;gt;&lt;/code> implementation. We want the processing of this element to be lightning fast as we will hold up the stream if we try do asynchronous processing, especially since the contract of &lt;code>IObserver&amp;lt;T&amp;gt;&lt;/code> does not support asynchronicity. To work around this, we are going to use &lt;code>System.Threading.Channels&lt;/code> to write to a temporary channel and pick this up in a background service that can do the aggregation of the metrics before publishing. I strongly recommend that you read &lt;a href="https://www.stevejgordon.co.uk/an-introduction-to-system-threading-channels">Steve Gordons excellent introduction to System.Threading.Channels&lt;/a> for background on this subject:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CloudwatchMetricObserver&lt;/span> : IObserver&amp;lt;MetricUpdate&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ChannelWriter&amp;lt;MetricUpdate&amp;gt; _channel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CloudwatchMetricObserver(ChannelWriter&amp;lt;MetricUpdate&amp;gt; channel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _channel = channel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnCompleted() { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnError(Exception error) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnNext(MetricUpdate &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _channel.TryWrite(&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>By proxying the metrics through a channel, we have a unique ability to batch the data in our requests through a simple pattern in the background service. The rough flow is:&lt;/p>
&lt;ul>
&lt;li>Check to see if there is an element in the channel. If an element is present:
&lt;ul>
&lt;li>Add it to a temporary list of metrics&lt;/li>
&lt;li>If we have hit the capacity of our temporary storage, publish the metrics&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If no element in the channel:
&lt;ul>
&lt;li>Publish any remaining metrics (eg: if we haven&amp;rsquo;t hit the capacity)&lt;/li>
&lt;li>Wait for the stop signal or an element to appear in the channel, whichever is first&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>This flow is what I&amp;rsquo;ve implemented below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CloudwatchPublishingService&lt;/span> : BackgroundService
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ICloudWatchMetricsPublisher _publisher;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ILogger&amp;lt;CloudwatchPublishingService&amp;gt; _logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ChannelReader&amp;lt;MetricUpdate&amp;gt; _metricReader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> _capacity = &lt;span style="color:#ae81ff">20&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&amp;lt;MetricUpdate&amp;gt;? _metrics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CloudwatchPublishingService(ICloudWatchMetricsPublisher publisher,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ILogger&amp;lt;CloudwatchPublishingService&amp;gt; logger,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ChannelReader&amp;lt;MetricUpdate&amp;gt; metricReader)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _publisher = publisher;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _logger = logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metricReader = metricReader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task ExecuteAsync(CancellationToken cancellationToken)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> Task PublishAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_metrics &lt;span style="color:#66d9ef">is&lt;/span> {} &amp;amp;&amp;amp; _metrics.Count &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> _publisher.PublishMetricsAsync(_metrics);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Ensure that we reset the metric container after publishing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metrics = &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (!cancellationToken.IsCancellationRequested)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_metricReader.TryRead(&lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> metric))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We don&amp;#39;t want to make API requests on every metric as this will cost a bucket load and is horribly inefficient&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metrics ??= &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;MetricUpdate&amp;gt;(_capacity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metrics.Add(metric);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_metrics.Count &amp;gt;= _capacity)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> PublishAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> PublishAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> _metricReader.WaitToReadAsync(cancellationToken);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (Exception exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _logger.LogError(exception, exception.Message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the code above, we&amp;rsquo;ve explicitly set the capacity of our temporary storage to 20, as this is the limitation imposed on us by the CloudWatch &lt;code>PutMetricData&lt;/code> endpoint. For those familiar with System.Threading.Channels, I have explicitly chosen not to use the &lt;code>IAsyncEnumerable&lt;/code> support so that I have more control over the batching, ie: I don&amp;rsquo;t have to wait for a complete batch of 20 metrics before I send the request the data be stored in CloudWatch. This can help with terminal scenarios where you may be able to get additional metrics out before the service dies, and when there are long intervals between metrics being published.&lt;/p>
&lt;p>The last piece of the puzzle is to link the &lt;code>MetricsCollectionService&lt;/code> from the &lt;a href="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/#processing-events">previous article&lt;/a> (some parts removed for brevity) with the &lt;code>IMetricsObservable&lt;/code> we&amp;rsquo;ve just created:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MetricsCollectionService&lt;/span> : EventListener, IHostedService
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> IMetricsObservable _metricsObservable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MetricsCollectionService(IMetricsObservable metricsObservable)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metricsObservable = metricsObservable ?? &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentNullException(nameof(metricsObservable));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnEventWritten(EventWrittenEventArgs eventData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (eventData.EventName != &lt;span style="color:#e6db74">&amp;#34;EventCounters&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> || eventData.Payload.Count &amp;lt;= &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> || !(eventData.Payload[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">is&lt;/span> IDictionary&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">object&lt;/span>&amp;gt; data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> || !data.TryGetValue(&lt;span style="color:#e6db74">&amp;#34;CounterType&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> counterType)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> || !data.TryGetValue(&lt;span style="color:#e6db74">&amp;#34;Name&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> name))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> metricType = counterType.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> metricValue = &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;Sum&amp;#34;&lt;/span>.Equals(metricType) &amp;amp;&amp;amp; data.TryGetValue(&lt;span style="color:#e6db74">&amp;#34;Increment&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> increment))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metricValue = Convert.ToSingle(increment);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;Mean&amp;#34;&lt;/span>.Equals(metricType) &amp;amp;&amp;amp; data.TryGetValue(&lt;span style="color:#e6db74">&amp;#34;Mean&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> mean))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metricValue = Convert.ToSingle(mean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> metric = &lt;span style="color:#66d9ef">new&lt;/span> MetricUpdate(metricName, metricValue, tags);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metricsObservable.WriteMetric(&lt;span style="color:#66d9ef">ref&lt;/span> metric);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Naturally, if you don&amp;rsquo;t need the flexibility of adding multiple destinations, then you can bypass some of the code that I&amp;rsquo;ve shown above and go direct to the publisher instead of through the &lt;code>IMetricsObservable&lt;/code> indirection.&lt;/p>
&lt;p>That&amp;rsquo;s it for this article, I hope you&amp;rsquo;ve learned how we can publish metrics to CloudWatch in C# and how we can link this with our &lt;a href="http://localhost:1313/series/diagnostics-in-.net-core-3/">previous work&lt;/a> on .NET Event Counters. Happy Metrics Collection!&lt;/p></description></item><item><title>Building a Zero Trust Architecture In AWS</title><link>https://im5tu.io/article/2020/12/building-a-zero-trust-architecture-in-aws/</link><pubDate>Sat, 05 Dec 2020 15:38:58 +0000</pubDate><guid>https://im5tu.io/article/2020/12/building-a-zero-trust-architecture-in-aws/</guid><description>&lt;p>In the vast majority of companies that I&amp;rsquo;ve been in, software engineering &amp;amp; infrastructure best practises have often been left as something that needs to be updated later because building the product comes first. This is completely understandable as if you don&amp;rsquo;t have a product, you don&amp;rsquo;t have employment. This presents problems later when companies are beginning to scale rapidly and become popular. Not only does the company becomes a target for malicious actors, but security-related incidents can easily occur by leaving storage devices open accidentally. Once a malicious actor is in your system, you usually have pretty big problems unless you design your architectures with Zero Trust in mind.&lt;/p>
&lt;h2 id="what-is-a-zero-trust-architecture">What is a Zero Trust Architecture&lt;/h2>
&lt;p>Zero trust means many different things to many different people, but the concept has its origins in Network Security. A Zero Trust Architecture aims to remove any source of inherent trust from the network, treat it as hostile and instead gain confidence that you can trust a connection through techniques like authentication and encryption. Zero Trust Architectures form a part of a more well-rounded defense in depth strategy.&lt;/p>
&lt;p>The path to a fully Zero Trust Architecture is a long one, which you may argue is never complete because infrastructure rarely becomes stagnant and are always evolving. It&amp;rsquo;s important to recognise that moving to this style of architecture can be time-consuming and you should do so with care and plenty of testing before removing any existing control infrastructure. The following principals are a combination of some of the recommendations from national security bodies, AWS best practises and best practises that I consider important. This is not intended to be an exhaustive list, but form part of your research or provide a basic understanding.&lt;/p>
&lt;h2 id="zero-trust-architecture-principals">Zero Trust Architecture Principals&lt;/h2>
&lt;p>Here are the principals that we are going to cover:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#authentication--authorization-everywhere">Authentication &amp;amp; Authorization Everywhere&lt;/a>&lt;/li>
&lt;li>&lt;a href="#limit-the-scope-of-permissions">Limit the scope of permissions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#encryption-at-rest--in-transit">Encryption At-Rest &amp;amp; In-Transit&lt;/a>&lt;/li>
&lt;li>&lt;a href="#prefer-managed-services">Prefer Managed Services&lt;/a>&lt;/li>
&lt;li>&lt;a href="#vpc-subnet-isolation--endpoints">VPC Subnet Isolation &amp;amp; Endpoints&lt;/a>&lt;/li>
&lt;li>&lt;a href="#use-transit-gateway-to-connect-vpcs">Use Transit Gateway to connect VPCs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#choose-standards-where-possible">Choose Standards Where Possible&lt;/a>&lt;/li>
&lt;li>&lt;a href="#store-secrets-securely">Store secrets securely&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="authentication--authorization-everywhere">Authentication &amp;amp; Authorization Everywhere&lt;/h3>
&lt;p>As mentioned earlier, part of the zero-trust model is not to trust anything by removing inherent trust. Authentication ensures that the requester is who they say they are, whereas authorization gives the requester access to resources.&lt;/p>
&lt;p>Authentication everywhere means that we ensure that users, services and devices are successfully authenticated before performing any actions. Once authenticated, the entry point for each action checks the authorization of the user to ensure that they have the relevant permissions to perform the action. Frameworks like Asp.NET Core make this easy through the use of code-based policies in the identity framework.&lt;/p>
&lt;p>Cloud providers typically have a robust identity and access management (IAM) system in place which removes the need to store credentials in services. Instead, credentials are derived from the service context and are authenticated on each request. If possible, avoid storing the credentials of a service that you need to access and favour service roles that have permissions to access the resources, leveraging the cloud providers IAM infrastructure. You can see the &lt;a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">AWS IAM Security Best Practises Here&lt;/a>.&lt;/p>
&lt;p>For users in your organization, one easy to add protection layer is to ensure multi-factor authentication (MFA) is enabled for the services that support it. Typically this is added to authentication systems to prevent malicious actions when a password is compromised. In addition, some cloud providers and services allow you to enforce MFA when deleting or changing resources, preventing damaging actions for an already authenticated user.&lt;/p>
&lt;h3 id="limit-the-scope-of-permissions">Limit the scope of permissions&lt;/h3>
&lt;p>One of the tendencies when building out services is to give a service full administration privileges, usually when troubleshooting or initial development. Unfortunately, it is common to see that these elevated permissions are left in-place when troubleshooting has completed and the service is running as normal. Instead, start with a minimum set of permissions and grant additional permissions as necessary - without going to full administration privileges from the start. Doing so is more secure than starting with permissions that are too lenient and then trying to tighten them later. This is also known as the principal of least privilege.&lt;/p>
&lt;p>An example of this would be a reporting service. Typically, a reporting service does not have a requirement to write data to a database, only to extract and present to the user. In a zero-trust model, we would create a unique login for the reporting service and limit it&amp;rsquo;s access to only those database entries it requires. We would also ensure that the user is a read-only user so if the service is compromised then a malicious actor cannot insert or alter any of the data stored in the database.&lt;/p>
&lt;p>AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity&amp;rsquo;s permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Add IAM users into IAM Roles to make the management role-based rather than elevating individual users. With role-based permissions, you should limit the scope to only the permissions that are required for the role the users fulfil, exactly like we do with services. With multiple teams, the permissions should be limited to the infrastructure components that the team manages. For example, do not give access to all DynamoDB instances.&lt;/p>
&lt;p>For organizations, you can investigate the use of a service control policy (SCP). Service control policies are a type of organization policy that you can use to manage permissions in your organization. SCP&amp;rsquo;s offer central control over the maximum available permissions for all accounts in your organization. SCP&amp;rsquo;s alone are not sufficient to granting permissions to the accounts in your organization. No permissions are granted by an SCP. An SCP defines a guardrail, or sets limits, on the actions that the account&amp;rsquo;s administrator can delegate to the IAM users and roles in the affected accounts.&lt;/p>
&lt;p>Here is an example of a limited IAM policy: &lt;img src="iam-policy.png" alt="Limited IAM Policy for SNS">&lt;/p>
&lt;p>You can read more about &lt;a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">AWS IAM Policy Boundaries here&lt;/a> and &lt;a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_scps.html">Service Control Policies here&lt;/a>.&lt;/p>
&lt;h3 id="encryption-at-rest--in-transit">Encryption At-Rest &amp;amp; In-Transit&lt;/h3>
&lt;p>Over the past couple of years, we&amp;rsquo;ve seen a massive movement towards securing websites with certificates and ensuring that all traffic is sent via HTTPS. Protocols like &lt;a href="https://letsencrypt.org/docs/client-options/">ACME&lt;/a> and &lt;a href="https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html">HSTS&lt;/a> help ensure that implementation of HTTPS is easy, cheaper and consistent. Unfortunately, the security story usually ends there for most organizations unless there is a regulatory reason. We need to consider both Encryption At Rest and Encryption In-Transit.&lt;/p>
&lt;p>Encryption In-Transit refers to the encryption that&amp;rsquo;s applied to data as it transits from one system to another. For the web, this is often seen as HTTPS but Encryption In-Transit includes any data that is sent over the network meaning that we need to take a look at all the protocols we use like web sockets, AMQP and SQL. It is often possible to use a TLS based connection to meet this part of the principal. Using TLS everywhere doesn&amp;rsquo;t guarantee the service is authenticated, just that the connection is secured and it hasn&amp;rsquo;t be changed inflight. You may consider implementing &lt;a href="https://www.docusign.com/blog/dsdev-mutual-tls-stuff-know">mutual TLS&lt;/a> (or MTLS) for additional authentication requirements.&lt;/p>
&lt;p>Encryption At Rest refers to the encryption that&amp;rsquo;s applied to data when it is persisted to disk. When building out infrastructure, engineers tend to only think about data storage areas like DynamoDB, S3 and SQL Server as places that they need to have encryption at rest. When looking at the architecture holistically, we need to consider a lot more which often requires digging into provider-specific documentation to find the answers. Here are a few examples from AWS, where data can be persisted on disk for the purposes of retries and reliability:&lt;/p>
&lt;p>&lt;strong>SQS&lt;/strong>&lt;/p>
&lt;p>In-transit encryption is provided, but you must opt-in to at-rest encryption: &lt;img src="sqs-encryption.png" alt="SQS Encryption">&lt;/p>
&lt;p>&lt;strong>SNS&lt;/strong>&lt;/p>
&lt;p>In-transit encryption is provided, but you must opt-in to at-rest encryption: &lt;img src="sns-encryption.png" alt="SNS Encryption">&lt;/p>
&lt;p>By performing end to end encryption both at rest and in-transit, we often meet any regulatory needs such as PCI and GDPR compliance. In the UK, the Information Commissioner&amp;rsquo;s Office can now issue fines of up to 4% of a company&amp;rsquo;s annual turnover, or 20 million (whichever is greater) for the worst data offences - so this is something that we should always be considering.&lt;/p>
&lt;h3 id="prefer-managed-services">Prefer Managed Services&lt;/h3>
&lt;p>Another common pattern that I see is the use of custom-built services where a suitable managed service exists. A classic example of this is SQL database servers. Most cloud providers have managed service offerings which look after key parts of the platform like patching of the OS, replication and more. Moreover, they usually implement the best security practises, or at least offer them as a useable template. The chances are you&amp;rsquo;re like me and not an expert in configuring these systems, so it&amp;rsquo;s best to leave it to the professionals unless we have a legitimate case for managing it ourselves. Even then, we need to challenge all the aspects of the self-hosted use case to ensure that it fits we our desired security profile.&lt;/p>
&lt;h3 id="vpc-subnet-isolation--endpoints">VPC Subnet Isolation &amp;amp; Endpoints&lt;/h3>
&lt;p>Most cloud providers allow you to isolate your compute resources into a separate area, called a Virtual Private Cloud (VPC). You can easily customize the network configuration of your VPC. You can assign a CIDR range and configure your subnets in accordance with your business requirements. There are four types of subnets that you should consider implementing:&lt;/p>
&lt;ul>
&lt;li>Public subnets: Anything that should be internet accessible, eg: NAT Gateways, Bastion hosts etc&lt;/li>
&lt;li>Private subnets: Accessible from the public subnets. Has access to database &amp;amp; intra subnets. Able to talk to the internet.&lt;/li>
&lt;li>Database subnets: Only accessible from private and intra subnets. Typically no internet access available to instances.&lt;/li>
&lt;li>Intra subnets: Services that access resources that live inside of the VPC and require no internet access. AWS resources will require a &lt;a href="https://im5tu.io/article/2023/01/observed-no.-1-vpc-endpoint-policies/">VPC Endpoint&lt;/a> to work.&lt;/li>
&lt;/ul>
&lt;p>Even when inside of a VPC in AWS, it is a little known fact that your traffic to AWS services will traverse via the public internet. The solution to this is &lt;a href="https://im5tu.io/article/2023/01/observed-no.-1-vpc-endpoint-policies/">VPC Endpoints&lt;/a>. A &lt;a href="https://im5tu.io/article/2023/01/observed-no.-1-vpc-endpoint-policies/">VPC Endpoint&lt;/a> enables private connections between your VPC and supported AWS services and &lt;a href="https://im5tu.io/article/2023/01/observed-no.-1-vpc-endpoint-policies/">VPC Endpoint&lt;/a> services powered by AWS PrivateLink. AWS PrivateLink is a technology that enables you to privately access services by using private IP addresses. Traffic between your VPC and the other service does not leave the Amazon network. A &lt;a href="https://im5tu.io/article/2023/01/observed-no.-1-vpc-endpoint-policies/">VPC Endpoint&lt;/a> does not require an internet gateway, virtual private gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances in your VPC do not require public IP addresses to communicate with resources in the service.&lt;/p>
&lt;p>For serverless architectures, we may be utilizing Lambdas for the scaling capabilities it can provide. A Lambda may execute outside of a VPC entirely, as shown in the picture below. This means it would by-pass any protections that you have inside of your VPC. I would personally recommend that all functions are isolated into their own subnets inside of your VPC.&lt;/p>
&lt;p>&lt;img src="lambda-vpc.png" alt="Lambda VPC">&lt;/p>
&lt;h3 id="use-transit-gateway-to-connect-vpcs">Use Transit Gateway to connect VPCs&lt;/h3>
&lt;p>In AWS, you can configure a transit gateway to route internal traffic between VPCs. AWS Transit Gateway can be configured with or without route propagation. It&amp;rsquo;s advised to explicitly set the associations between your VPCs so that you know what connects to what. This forms part of the know your network and services that the National Cyber Security Centre advises. An example of how to set this up using terraform can be found &lt;a href="https://medium.com/driven-by-code/aws-transit-gateway-routing-in-multiple-accounts-713b10ca7b34">here&lt;/a>.&lt;/p>
&lt;p>A secondary advantage of using transit gateway is that it has a robust monitoring solution in-place. This is vital for a zero-trust architecture because you need to know and understand your network. You may also define a network access control list (NACL) as an optional layer of security.&lt;/p>
&lt;h3 id="choose-standards-where-possible">Choose Standards Where Possible&lt;/h3>
&lt;p>Whenever possible, use standards-based technologies. This allows interoperability between devices and services. A good example of which is authentication and authorization, where common standards such as OpenID Connect, OAuth or SAML allow you to use a single directory service to authenticate to many services. Moreover, when you are (re)implementing something that already exists, you are likely missing the thousands of peer-reviews that typically happens for widely adopted standards. You are also not going to get any on-going support either from standards bodies or the surrounding communities. If there are tool chains in your organization, try to standardize on them. For example, if you have a toolchain for authentication, use the same toolchain everywhere and ensure that it is consistently configured through the use of packages (ie: NPM/NuGet packages).&lt;/p>
&lt;h3 id="store-secrets-securely">Store secrets securely&lt;/h3>
&lt;p>Occasionally, we will have configuration settings that need to be kept secret, these will often change on a per-environment basis. A typical approach would be to use Octopus Deploy&amp;rsquo;s variables to keep these values secure and then deploy a new task definition with the variables set as environment variables on the task definitions. This represents a number of problems as the values are stored in plain text in the task definition and available on the container in plaintext. This means that a malicious actor could extract these values pretty easily from either the host or the running container depending on which has been compromised. A better approach would be to use AWS Secrets Manager or AWS Parameter Store to store the configuration settings and pull these directly from with your application code. Both AWS services can then be limited to a few select users to manage the configuration, such as engineering leads. With this approach, the configuration is no longer accessible without doing a direct memory dump from within the container.&lt;/p>
&lt;p>When we come around to highly confidential information, we should be looking into the use of Nitro Enclaves. AWS Nitro Enclaves enables customers to create isolated compute environments to further protect and securely process highly sensitive data such as personally identifiable information (PII), healthcare, financial, and intellectual property data within their Amazon EC2 instances.&lt;/p>
&lt;h2 id="enforcing-compliance-in-zero-trust-architectures">Enforcing Compliance In Zero Trust Architectures&lt;/h2>
&lt;p>Having a set of guiding principals is a good start towards a zero-trust architecture but the most important aspect of it is observation and compliance.&lt;/p>
&lt;h3 id="observability">Observability&lt;/h3>
&lt;p>One of the most important aspects of zero-trust architectures is the use of monitoring. AWS, as mentioned above, has a number of great tools built into the products for the purposes of monitoring and alerting. Monitoring ideally is continuous, but it can also be periodic in nature. Alerting should be setup for the aspects of the systems that you are most concerned about. For example, you may have an alert for when a critical security group is modified. The remediation of the alert may be automatic, but you should be aware that the violation has occurred in the first place.&lt;/p>
&lt;h3 id="compliance">Compliance&lt;/h3>
&lt;p>There are two forms of compliance that we need to consider: pre-deployment / post-deployment.&lt;/p>
&lt;p>Pre-deployment validation can be a little tricky depending on the toolchain that you use. If you use &lt;a href="https://www.terraform.io/">Terraform&lt;/a> then you have a couple of choices: &lt;a href="https://www.hashicorp.com/products/terraform/editions/cloud">Terraform Enterprise&lt;/a> and &lt;a href="https://spacelift.io/">SpaceLift&lt;/a>. Both allow for a form of codified policies which can prevent resources being created if they don&amp;rsquo;t match specific standards.&lt;/p>
&lt;p>Post-deployment could easily be handled by tools like &lt;a href="https://cloudcustodian.io/">CloudCustodian&lt;/a>. CloudCustodian allows you to define a series of policies that ensure your infrastructure follows a set of defined guidelines. Should a policy be violated, you have the choice on whether to act on the violation. For example, you may want to turn off an EC2 instance if the root storage device is not encrypted with a KMS key.&lt;/p>
&lt;p>In reality, you will likely need a combination of pre &amp;amp; post-deployment compliance as there will always be scenarios where infrastructure is changed manually or a malicious actor could spin up new infrastructure.&lt;/p>
&lt;p>Hopefully you now have a good understanding of what is meant by zero-trust architectures and you can leverage some of the tools and techniques mentioned to improve your security posture. I thoroughly recommend that you read through the &lt;a href="https://github.com/ukncsc/zero-trust-architecture">National Cyber Security Centre - Zero Trust Architecture&lt;/a> repository for more information on some of the topics listed in this post.&lt;/p></description></item></channel></rss>