<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>October on CodeWithStu's Blog</title><link>https://im5tu.io/article/2022/10/</link><description>Recent content in October on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2022/10/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET Core Versioning: Minimal APIs</title><link>https://im5tu.io/article/2022/10/asp.net-core-versioning-minimal-apis/</link><pubDate>Tue, 04 Oct 2022 12:00:00 +0100</pubDate><guid>https://im5tu.io/article/2022/10/asp.net-core-versioning-minimal-apis/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/YRJGKyzjFlY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>This blog post is also available as a video on my &lt;a href="https://codewithstu.tv">YouTube Channel&lt;/a>.&lt;/em>&lt;/p>
&lt;p>If your API is a key part of your product you are going to want to version your APIs. One of the major reasons that we consider versioning our api’s is so that we provide a consistent experience for our users. If we consistently change our API’s then our consumers will break, they will get annoyed and eventually leave our product.&lt;/p>
&lt;p>There are three main ways that you can version your API’s:&lt;/p>
&lt;ul>
&lt;li>Headers&lt;/li>
&lt;li>Querystring&lt;/li>
&lt;li>Urls&lt;/li>
&lt;/ul>
&lt;p>I don’t believe there is a right way to do versioning, so I am going to show you all three approaches in this article and let you decide which one is best for your scenario. The article specifically looks at ASP.NET Core Minimal APIs. For MVC APIs, go &lt;a href="https://im5tu.io/article/2022/09/asp.net-core-versioning-mvc-apis/">here&lt;/a>.&lt;/p>
&lt;h2 id="versioning-setup">Versioning Setup&lt;/h2>
&lt;p>Depending on whether we are working with Minimal APIs or MVC depends on which NuGet package we need to add. For MVC based APIs we need to add the &lt;code>Asp.Versioning.Http&lt;/code> package from NuGet.&lt;/p>
&lt;p>It’s worth noting that the name of this package has changed from the previous &lt;code>Microsoft.AspNetCore.Mvc.Versioning&lt;/code> package because the main contributor to the repository has now left Microsoft and can’t reuse the Microsoft prefix. You can read more about this &lt;a href="https://github.com/dotnet/aspnet-api-versioning/discussions/807">here&lt;/a>.&lt;/p>
&lt;p>Once we’ve add the correct NuGet package for our API type, we can head over to our service collection and call &lt;code>AddApiVersioning&lt;/code> - we will want the options later on, so I’m going to setup that lambda function now:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning.Conventions;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> version1 = &lt;span style="color:#66d9ef">new&lt;/span> ApiVersion(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> version2 = &lt;span style="color:#66d9ef">new&lt;/span> ApiVersion(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> builder = WebApplication.CreateBuilder(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We will change this later on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> app = builder.Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.Run();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="versioning-strategy">Versioning Strategy&lt;/h2>
&lt;p>One minor thing that you need to consider before you is what style of versioning numbers you’re going to have. For example, I use a major only strategy in which I use a single number to describe a version, eg: v1. Another common versioning strategy is to use a major/minor setup, eg: 1.0.&lt;/p>
&lt;p>You’ll also need to consider how much a version covers for an API. For me, I have versioning setup on a per endpoint basis, but I have also seen all endpoints on an API be versioned as one.&lt;/p>
&lt;p>There is no right strategy for you to pick here, it all depends on your requirements and what you think is easiest for you to manage vs the experience for your consumers. For the rest of this article, I am going to use my standard setup of major-only versioning on a per endpoint basis.&lt;/p>
&lt;h2 id="adding-versions-to-minimal-apis">Adding versions to Minimal APIs&lt;/h2>
&lt;p>The setup for a minimal API is a bit different to what we would normally do in the MVC world. First we need to create a version set which tells the API versioning subsystem which versions are available to be used. Here we can set some common options like whether to report API Versions or not:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> app = builder.Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> versionSet = app.NewApiVersionSet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .HasApiVersion(version1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .HasApiVersion(version2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From there we are versioning each endpoint by first calling &lt;code>WithApiVersionSet&lt;/code> passing in our version set, before either mapping it to a specific version with &lt;code>MapToApiVersion&lt;/code> or making it version agnostic with &lt;code>.IsApiVersionNeutral()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.WithApiVersionSet(versionSet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.HasApiVersions(&lt;span style="color:#66d9ef">new&lt;/span> [] {version1, version2});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this setup is done, for the most part, the api versioning setup is exactly the same in terms of where to get the api version from.&lt;/p>
&lt;h2 id="versioning-via-headers">Versioning via Headers&lt;/h2>
&lt;p>The first way that we can read the version of the request is to use headers. When using a header, we have two approaches that we can use:&lt;/p>
&lt;ul>
&lt;li>We can use an extension to the Accept header&lt;/li>
&lt;li>Or we can use a custom header&lt;/li>
&lt;/ul>
&lt;p>To use the media type we use the options we created earlier to add in:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> MediaTypeApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/media-header.png" alt="Verification in Postman using the Accept header">&lt;/p>
&lt;p>To use a custom header such as &lt;code>X-Api-Version&lt;/code> we need to change the ApiVersionReader to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> HeaderApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;X-Api-Version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/custom-header.png" alt="Verification in Postman using the Custom header">&lt;/p>
&lt;h2 id="versioning-via-querystrings">Versioning via QueryStrings&lt;/h2>
&lt;p>The next way of versioning our urls is to use a querystring parameter. Here we will change the type of ApiVersionReader to &lt;code>QueryStringApiVersionReader&lt;/code> and pass in the name of the parameter that we will use as part of the querystring to provide the version information:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> QueryStringApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/querystring.png" alt="Verification in Postman using a querystring">&lt;/p>
&lt;h2 id="versioning-via-urls">Versioning via URLs&lt;/h2>
&lt;p>The last major way of adding in versioning information is to use URLs. To add the version information to the URL we need to modify the route itself. Instead of changing an attribute like we would in MVC, we just need to edit the route information passed into MapGet, MapPut etc. We put in the new path segment in the exact same way as we did for the MVC route segements, ie: we add a new segment to our URL called &lt;code>version&lt;/code> limited to the type &lt;code>apiVersion&lt;/code>. This is a special validation that’s created by the versioning package to ensure that correct values are passed in and the correct actions are called:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;v{version:apiVersion}/weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.WithApiVersionSet(versionSet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.HasApiVersions(&lt;span style="color:#66d9ef">new&lt;/span> [] {version1, version2});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this is setup for your application, the last bit that we need to do is change the ApiVersionReader in the versioning options. We use the type &lt;code>UrlSegementApiVersionReader&lt;/code> to make the package read from the route data instead.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> UrlSegmentApiVersionReader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/url.png" alt="Verification in Postman using a route parameter">&lt;/p>
&lt;h2 id="other-versioning-options">Other versioning options&lt;/h2>
&lt;p>There are other things that we can do with this package such as specifying the default version when one is not specified and reporting the supported and deprecated versions in our responses.&lt;/p>
&lt;p>To set the default version, we would set the option &lt;code>AssumeDefaultVersionWhenUnspecified&lt;/code> to &lt;code>true&lt;/code> and then &lt;code>DefaultApiVersion&lt;/code> to the default version that you wish to be assumed. Note, that this will only work if you are using the header or querystring versioning strategies.&lt;/p>
&lt;p>We can also specify which versions are depreciated and which ones are not. There’s slightly different ways of doing this. In MVC APIs we would set the deprecated flag on the ApiVersion attribute that we decorate our controllers and actions with. For minimal APIs we call &lt;code>HasDepecatedApiVersion&lt;/code> with the relevant version number on the version set that we are using. Once this is done, for both MVC and Minimal APIs we set &lt;code>ReportApiVersions&lt;/code> equal to true in the options and start getting the headers &lt;code>api-deprecated-versions&lt;/code> and &lt;code>api-supported-versions&lt;/code> returned as part of responses. These headers contain a comma separated list of supported versions.&lt;/p>
&lt;p>&lt;em>The full code for this is available to my &lt;a href="https://github.com/sponsors/im5tu">Github Sponsors&lt;/a>.&lt;/em>&lt;/p></description></item></channel></rss>