<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>February on CodeWithStu's Blog</title><link>https://im5tu.io/article/2022/02/</link><description>Recent content in February on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2022/02/index.xml" rel="self" type="application/rss+xml"/><item><title>3 Ways To Increase App Reliability With Polly</title><link>https://im5tu.io/article/2022/02/3-ways-to-increase-app-reliability-with-polly/</link><pubDate>Thu, 03 Feb 2022 08:30:00 +0000</pubDate><guid>https://im5tu.io/article/2022/02/3-ways-to-increase-app-reliability-with-polly/</guid><description>&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/4mWkb3tHDf0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>In this article, we&amp;rsquo;re going to take a look at the different ways that you can make your .NET applications more stable by using 3 different patterns: Retrying with decorrelated jitter, bulkheads and circuit breakers.&lt;/p>
&lt;p>In order to create highly resilient applications, we must embrace the fact that applications will fail, often at inopportune times. Failures can come in many forms such as temporary loss of services, complete service failure or timeouts. When failure occurs, we can choose whether or not we should retry the behaviour. Our ethos should be that all non-safe operations (eg: PUT/DELETE etc) should be idempotent so that we can retry the operation ensuring our applications complete the tasks correctly.&lt;/p>
&lt;h2 id="pattern-1---retry-policies-with-decorrelated-jitter">Pattern 1 - Retry Policies with decorrelated Jitter&lt;/h2>
&lt;p>The first pattern that we&amp;rsquo;re going to look at is retries with decorrelated jitter. When we write a retry policy with generally retry under the following conditions:&lt;/p>
&lt;ul>
&lt;li>Ensure retries are on all third party calls (eg: dynamo, http, sql)&lt;/li>
&lt;li>Retry on timeouts&lt;/li>
&lt;li>Retry on failures (eg: socket exceptions)&lt;/li>
&lt;li>Retry when HTTP Calls return a 5XX status code&lt;/li>
&lt;/ul>
&lt;p>When we retry, we generally have a period of time in which we backoff to allow the external system to recover. If we have a high amount of concurrent operations, then we will backoff and retry at the same time, potentially overloading the system again. To counteract this, we add randomness to the retry delays which is also known as jitter. Jitter has been shown to massively decrease the total operation duration in a failure scenario.&lt;/p>
&lt;p>Our library of choice when implementing retry policies is to use Polly. The team behind Polly, and its many contributors, have placed a lot of effort in behind finding an efficient way of using retry policies with jitter. Without jitter, our retry policies will be correlated like the below:&lt;/p>
&lt;p>&lt;img src="expo_backoff.png" alt="Exponential backoff">&lt;/p>
&lt;p>&lt;em>&lt;a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/">Image Credit&lt;/a>&lt;/em>&lt;/p>
&lt;p>However, with jitter, our retry policies will be a bit better:&lt;/p>
&lt;p>&lt;img src="exponential-backoff-and-jitter.png" alt="Exponential backoff with jitter">&lt;/p>
&lt;p>&lt;em>&lt;a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/">Image Credit&lt;/a>&lt;/em>&lt;/p>
&lt;p>The Polly team have spent &lt;a href="https://github.com/App-vNext/Polly/issues/530">a lot of time&lt;/a> coming up with a great decorrelated jitter implementation which flattens the curve and reduces the amount of overall work that needs to be done:&lt;/p>
&lt;p>&lt;img src="NewJitterFormulaRetryCount5InitialDelay1Second.png" alt="Polly decorrelated jitter implementation">&lt;/p>
&lt;p>This implementation is standard in all of my projects both in and outside of work. To use the implementation we need to import the &lt;code>Polly.Contrib.WaitAndRetry&lt;/code> &lt;a href="https://www.nuget.org/packages/Polly.Contrib.WaitAndRetry/">NuGet Package&lt;/a>, followed by setting up a new backoff policy:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> IAsyncPolicy&amp;lt;HttpResponseMessage&amp;gt; GetRetryPolicy(&lt;span style="color:#66d9ef">int&lt;/span> medianFirstRetryDelay = &lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> retryCount = &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> delay = Backoff.DecorrelatedJitterBackoffV2(medianFirstRetryDelay: TimeSpan.FromMilliseconds(medianFirstRetryDelay), retryCount: retryCount);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> HttpPolicyExtensions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .HandleTransientHttpError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WaitAndRetryAsync(delay);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>services.AddHttpClient(&lt;span style="color:#e6db74">&amp;#34;Client Name&amp;#34;&lt;/span>, client =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Your client setup, eg: setting up base address&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .AddPolicyHandler(GetRetryPolicy());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above implementation shows you how to use the retry policy alongside the HttpClientFactory provided by Microsoft via their NuGet package: &lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Http.Polly/">Microsoft.Extensions.Http.Polly&lt;/a>. When a transient request failure occurs, then the package will retry 7 times (default above) before returning an exception back to the caller. Each retry attempt will increase inline with the backoff policy defined by the Polly implementation ensuring that your apps have the best chance to succeed.&lt;/p>
&lt;h2 id="pattern-2---bulkhead">Pattern 2 - Bulkhead&lt;/h2>
&lt;p>The next pattern that we are going to take a look at is the bulkhead pattern. A bulkhead is used to control access to a common resource by multiple threads to avoid overloading it and causing cascading failures within a system. It does this by placing limits on what a system can process with a fixed length queue of pending requests. Once the pending request queue is full then the request is rejected and returned to the caller. This helps leave the system resources for requests that the system can process.&lt;/p>
&lt;p>We can visualize this with the diagram below:&lt;/p>
&lt;p>&lt;img src="Bulkhead-Policy.jpg" alt="Bulkhead Policy">&lt;/p>
&lt;p>We find the the maximum concurrent requests through &lt;a href="https://k6.io/docs/test-types/stress-testing/">stress testing&lt;/a> our target service so that we know what the breaking point of that service is. We then test our service under load to figure out how many pending requests we can have before our application starts to fail. I usually start with 2-4x our inflight requests number and increase/decrease depending on how the application performs.&lt;/p>
&lt;p>A bulkhead can be placed on either the client side or the server side, although it is more common to see it on the server side as that&amp;rsquo;s where the expensive computation occurs. As a minimum, we should provide the amount of concurrent requests (capacity below) and the amount of pending requests (queueLength below):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> IAsyncPolicy&amp;lt;HttpResponseMessage&amp;gt; GetBulkheadPolicy(&lt;span style="color:#66d9ef">int&lt;/span> capacity, &lt;span style="color:#66d9ef">int&lt;/span> queueLength)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Policy.BulkheadAsync&amp;lt;HttpResponseMessage&amp;gt;(capacity, queueLength);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>services.AddHttpClient(&lt;span style="color:#e6db74">&amp;#34;Client Name&amp;#34;&lt;/span>, client =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Your client setup, eg: setting up base address&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .AddPolicyHandler(GetBulkheadPolicy(&lt;span style="color:#ae81ff">50&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As with the retry example earlier, we&amp;rsquo;ve attached our policy to a HTTP client that we know can&amp;rsquo;t take a large volume of load. As soon as we hit 50 concurrent requests, the policy will add subsequent requests to the pending request queue. Once the pending request queue is full, then the policy will start rejecting any other calls to the service. Polly does provide an overload that takes an action should you need a callback when something has been rejected by the bulkhead policy.&lt;/p>
&lt;h2 id="pattern-3---circuit-breaker">Pattern 3 - Circuit Breaker&lt;/h2>
&lt;p>The next pattern that we are going to take a look at is the circuit breaker pattern. A circuit breaker detects the amount of faults in calls placed through it, and prevents calls when a configurable fault threshold is exceeded. For example, you are calling an API that is continously returning 500 status code results because of a failure condition. In this case, a circuit breaker would trigger and prevent calls from being forwarded to that service, giving it the opportunity to recover automatically. After a period of time, the circuit breaker would re-open and allow calls back to the hopefully recovered service.&lt;/p>
&lt;p>A circuit breaker has three states, as visualised below: Closed, Open, Half-Open&lt;/p>
&lt;p>&lt;img src="CircuitBreakerStates.png" alt="Circuit Breaker States">&lt;/p>
&lt;p>&lt;em>&lt;a href="https://github.com/App-vNext/Polly/wiki/Circuit-Breaker">Image Credit&lt;/a>&lt;/em>&lt;/p>
&lt;p>In the open state, no requests are forwarded to the target as the circuit breaker has detected it&amp;rsquo;s in a unhealthy state. In the closed state, requests are forwarded to the target system as normal. Whilst in the half-open state, each request is treated as an experiment to see whether or not the target system has recovered and places the circuit breaker in to the open/closed state depending on the result of the operation.&lt;/p>
&lt;p>Polly makes implementing this pattern really easy by providing us an &lt;code>AdvancedCircuitBreaker&lt;/code>. This is an improvement on the original &lt;code>CircuitBreaker&lt;/code> implementation as it now reacts on a proportion of failures which is measured over a duration of time. It also ensures that we have a minimum amount of throughput before it starts monitoring for failures.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> AsyncPolicy GetCircuitBreakerPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Policy.Handle&amp;lt;Exception&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .AdvancedCircuitBreakerAsync(&lt;span style="color:#ae81ff">0.5&lt;/span>, TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">10&lt;/span>), &lt;span style="color:#ae81ff">100&lt;/span>, TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">5&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we specify four configuration parameters, in order:&lt;/p>
&lt;ul>
&lt;li>Failure percentage: a value between 0 and 1 that specifies the threshold of failures. For example, a value of &lt;code>0.5&lt;/code> would indicate a 50% failure rate&lt;/li>
&lt;li>Monitoring period: The amount of time that we should monitor calls for. For example: within a ten second period, we would need 50% failures for the circuit breaker to trigger&lt;/li>
&lt;li>Minimum load: The minimum number of calls within that monitoring period that we would need in order for the circuit breaker to trigger. For example, we would need a 50% failure rate within a ten second period once with a minimum of 100 calls (so 50 calls would need to fail)&lt;/li>
&lt;li>Cooldown: Once the circuit breaker has triggered, the state will revert to closed after the specified cool down period&lt;/li>
&lt;/ul>
&lt;p>This policy is very flexible so I suggest that you read the &lt;a href="https://github.com/App-vNext/Polly/wiki/Advanced-Circuit-Breaker">Polly documentation&lt;/a> before implementing.&lt;/p>
&lt;h2 id="combining-multiple-policies">Combining multiple policies&lt;/h2>
&lt;p>Whilst all of the policies that we&amp;rsquo;ve seen here can be game changers for our applications, if we combine them, then they become even more powerful. I typically implement both the decorrelated jitter and the bulkhead together to constrain the resources used by any given service. To do this, Polly offers a simple extension called &lt;code>Wrap&lt;/code> which takes multiple policies and executes them in the order specified as a brand new policy.&lt;/p>
&lt;p>&lt;code>Policy.WrapAsync&lt;/code> takes 2 or more policies and wraps them from left to right as the outermost policy to the innermost policy. Let&amp;rsquo;s take a look at the following example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Polly;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Polly.Bulkhead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Polly.Contrib.WaitAndRetry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> policy = Policy.WrapAsync(GetRetryPolicy(), GetBulkheadPolicy(&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>policy.ExecuteAsync(&lt;span style="color:#66d9ef">async&lt;/span> () =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Starting task: &amp;#34;&lt;/span> + i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> Task.Delay(&lt;span style="color:#ae81ff">250&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Finished task: &amp;#34;&lt;/span> + i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> AsyncPolicy GetRetryPolicy(&lt;span style="color:#66d9ef">int&lt;/span> retryCount = &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> delay = Backoff.DecorrelatedJitterBackoffV2(medianFirstRetryDelay: TimeSpan.FromMilliseconds(&lt;span style="color:#ae81ff">50&lt;/span>), retryCount: retryCount);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Policy.Handle&amp;lt;Exception&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WaitAndRetryAsync(delay, ((exception, span, arg3, arg4) =&amp;gt; Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Retrying task&amp;#34;&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> AsyncBulkheadPolicy GetBulkheadPolicy(&lt;span style="color:#66d9ef">int&lt;/span> capacity, &lt;span style="color:#66d9ef">int&lt;/span> queueLength)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Policy.BulkheadAsync(capacity, queueLength, context =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Rejected Call&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Task.CompletedTask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This would produce a policy similar to the following:&lt;/p>
&lt;p>&lt;img src="WrappedPolicies.jpg" alt="Wrapped Policies">&lt;/p>
&lt;p>Once the returned policy is executed, then the retry policy is invoked with it&amp;rsquo;s action to be calling the bulkhead policy, which in turn invokes the action specified by the user. This means, in the above example, that we can have all of our calls to our downstream service including those that are retried, all going through the same bulkhead policy that we&amp;rsquo;ve implemented. This can help relieve tension on the underlying system.&lt;/p>
&lt;p>Hopefully the policies that I&amp;rsquo;ve shown you here will give you some ideas that you can implement into your systems and help your systems to remain more reliable under failure conditions such as load!&lt;/p></description></item></channel></rss>