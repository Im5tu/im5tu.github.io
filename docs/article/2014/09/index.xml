<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>September on CodeWithStu's Blog</title><link>https://im5tu.io/article/2014/09/</link><description>Recent content in September on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://im5tu.io/article/2014/09/index.xml" rel="self" type="application/rss+xml"/><item><title>Message Queue Fundamentals: MSMQ</title><link>https://im5tu.io/article/2014/09/message-queue-fundementals-msmq/</link><pubDate>Sun, 28 Sep 2014 18:35:57 +0000</pubDate><guid>https://im5tu.io/article/2014/09/message-queue-fundementals-msmq/</guid><description>&lt;p>MSMQ is Microsoft&amp;rsquo;s Message Queuing service that can be used to implement both synchronous and asynchronous solutions. Typically solutions are architectured using the available C++ APIâ€™s or via the relevant COM objects. The .Net Framework exposes the System.Messaging namespace which contains all the classes that you need to work with the MSMQ API.&lt;/p>
&lt;p>If you would like to read the first part to the article, &lt;a href="http://sblackler.net/2014/09/07/Message-Queue-Fundementals-Introduction/">click here to read about Message Queue Fundamentals&lt;/a>.&lt;/p>
&lt;p>In this article I will cover the following topics:&lt;/p>
&lt;ul>
&lt;li>Types of Queues in MSMQ
&lt;ul>
&lt;li>Application Queues
&lt;ul>
&lt;li>Public/Private Queues&lt;/li>
&lt;li>Transactional and non-transactional Queues&lt;/li>
&lt;li>Sub-Queues&lt;/li>
&lt;li>Administration Queues&lt;/li>
&lt;li>Response Queues&lt;/li>
&lt;li>Report Queues&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>System Queues
&lt;ul>
&lt;li>Journal Queues&lt;/li>
&lt;li>Internal Private Queues&lt;/li>
&lt;li>Dead-letter Queues&lt;/li>
&lt;li>Connector Queues&lt;/li>
&lt;li>Outgoing Queues&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Creating an MSMQ Message Queue&lt;/li>
&lt;li>Accessing an MSMQ Message Queue&lt;/li>
&lt;li>Sending a message to a MSMQ Message Queue
&lt;ul>
&lt;li>Sending a message to a MSMQ Message Queue using transactions&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Retrieving a message from a MSMQ Message Queue
&lt;ul>
&lt;li>Retrieving a message from a MSMQ Message Queue using transactions&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Before you begin, you need to have MSMQ installed on your machine, please do this by following &lt;a href="http://msdn.microsoft.com/en-us/library/aa967729(v=vs.110).aspx">these instructions&lt;/a>.&lt;/em>&lt;/p>
&lt;h2 id="types-of-queues-in-msmq">Types of Queues in MSMQ&lt;/h2>
&lt;p>This section describes the available queue types within MSMQ. Although I will not cover the consumption of all the available types of queue, I will briefly describe the following type of queue:&lt;/p>
&lt;ul>
&lt;li>Application Queues
&lt;ul>
&lt;li>Public/Private Queues&lt;/li>
&lt;li>Transactional and non-transactional Queues&lt;/li>
&lt;li>Sub-Queues&lt;/li>
&lt;li>Administration Queues&lt;/li>
&lt;li>Response Queues&lt;/li>
&lt;li>Report Queues&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>System Queues
&lt;ul>
&lt;li>Journal Queues&lt;/li>
&lt;li>Internal Private Queues&lt;/li>
&lt;li>Dead-letter Queues&lt;/li>
&lt;li>Connector Queues&lt;/li>
&lt;li>Outgoing Queues&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The quintessential difference between application and system queues is the ability to address messages to the queue. With application queues you can have, essentially, read/write capabilities, whereas you can only read messages from a system queue.&lt;/p>
&lt;h3 id="administration-queues">Administration Queues&lt;/h3>
&lt;h4 id="private-vs-public-queues">Private vs Public Queues&lt;/h4>
&lt;p>Deciding between a public and private queue depends on the requirements of the application and the infrastructure available. Public queues use Active Directory Domain Services to replicate the queue through the domain forest, providing reliability. They are both persistent and available to other applications. In contrast, private queues are only displayed on the local computer that contains them. Because private queues involve no replication, they are quicker to create, have lower latency and has no replication overhead as they are not distributed through a domain forest.&lt;/p>
&lt;p>&lt;em>For further on the permissions required for a public queue, please see &lt;a href="http://technet.microsoft.com/en-us/library/cc772532.aspx">this Technet article&lt;/a>.&lt;/em>&lt;/p>
&lt;h4 id="transactional-vs-non-transactional-queues">Transactional vs Non-Transactional Queues&lt;/h4>
&lt;p>As the name suggests, a transactional queue that only contains transactional messages. That is, when a message is written to/read from the queue the server/client must confirm the receipt of the message before the message can be removed from/added to the message queue. In contrast, a non-transactional queue each message is sent as a single operation (regardless of how many destinations the message is sent to), so there are no guarantees that messages will reach their destination. This is similar to TCP vs UDP. TCP (Transactional) guarantees message delivery where as UDP (Non-transactional) does not.&lt;/p>
&lt;p>&lt;em>For more information on transactional and non-transactional messaging, please see &lt;a href="http://msdn.microsoft.com/en-us/library/ms704006(v=vs.85).aspx">this MSDN article&lt;/a>.&lt;/em>&lt;/p>
&lt;h4 id="sub-queues">Sub-Queues&lt;/h4>
&lt;p>Sub-Queues are useful for a variety of scenarios including work order processing and poison message handling. Work order processing is the process in which line items are ordered in a more efficient manner for processing. Poison message handling involves dealing with messages that have exceeded the send timeout; hit the retry limit; or any application specific error such as a transaction timeout. For a more detailed explanation of poison messages, I would suggest reading the &lt;a href="http://msdn.microsoft.com/en-us/library/ms789028(v=vs.110).aspx">Poison Message Handling article on MSDN&lt;/a>.&lt;/p>
&lt;p>Unlike normal queues, the act of passing a message to a sub-queue invokes the creation of the queue if it does not already exist. If the sub-queue exists, the message is passed into the queue as normal. Furthermore, when the queue is empty and there are no open handles to the sub-queue, MSMQ removes the queue on your behalf. Apart from these main differences, sub-queues share the same properties as their parent queue, eg:&lt;/p>
&lt;ul>
&lt;li>Quota&lt;/li>
&lt;li>Access Control List (ACL)&lt;/li>
&lt;li>Transactional Type&lt;/li>
&lt;/ul>
&lt;h4 id="administration-queues-1">Administration Queues&lt;/h4>
&lt;p>Typically, you would not be accessing administration queues as they are application-generated for the purpose of positive/negative message acknowledgement. Although any non-transactional queue can be defined as an administration queue, I will not be covering this type of queue any further.&lt;/p>
&lt;h4 id="response-queues">Response Queues&lt;/h4>
&lt;p>Like administration queues, response queues are application generated that store application generated response messages returned by an application that is reading messages. Unlike administration queues however, any available queue can be specified as a response queue. Since MSMQ has no control over the contents of a message in a response queue, it is up to the receiving application to understand and process the message correctly.&lt;/p>
&lt;h4 id="report-queues">Report Queues&lt;/h4>
&lt;p>Each computer that has MSMQ installed can have a single report queue created on it. This is an application-generated queue that is used to store report messages that detail the route that the message took in order to reach its destination. The queue must have the following label and queue type identifier:&lt;/p>
&lt;ul>
&lt;li>Label: MQReport Queue&lt;/li>
&lt;li>Queue type identified: &lt;code>{55EE8F32-CCE9-11CF-B108-0020AFD61CE9}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>A report queue can either be created through Active Directory Users and Computers, or programmatically if the correct label and queue type identifier has been specified.&lt;/p>
&lt;h3 id="system-queues">System Queues&lt;/h3>
&lt;h4 id="journal-queues">Journal Queues&lt;/h4>
&lt;p>A journal queue is presented in two forms: A Queue Journal &amp;amp; A Computer Journal. A queue journal details all of the messages that have been removed from a queue. A computer journal contains copies of all the messages that are sent from a computer. Typically, you would use these queues for message diagnosis and audit purposes only.&lt;/p>
&lt;h4 id="internal-private-queues">Internal Private Queues&lt;/h4>
&lt;p>Internal queues are at the core of MSMQ. They are used as interim queues for storing and forwarding messages to a destination queue. They are not published in AD DS and are local to the current computer.&lt;/p>
&lt;h4 id="dead-letter-queues">Dead-Letter Queues&lt;/h4>
&lt;p>Dead-letter queues contain messages that cannot be delivered. MSMQ provides a transactional dead-letter queue and a non-transactional dead-letter queue. The process of storing undelivered messages on a source computer is sometimes referred to as negative source journalling. Applications can only read or delete messages from a dead letter queue. Sending to the queue is handled by the MSMQ internals.&lt;/p>
&lt;h4 id="connector-queues">Connector Queues&lt;/h4>
&lt;p>Simply put, Connector queues are used for cross-platform messaging. For a detailed guide on how this works, refer to the documentation &lt;a href="http://msdn.microsoft.com/en-us/library/ms706915(v=vs.85).aspx">on MSDN&lt;/a>.&lt;/p>
&lt;h4 id="outgoing-queues">Outgoing Queues&lt;/h4>
&lt;p>Outgoing queues are local internal queues that are used to store messages sent to remote queues. Messages can be stored in outgoing queues under off-line conditions and then sent to target queues on remote computers when connectivity is restored. These queues are generated automatically and cannot be created or deleted manually.&lt;/p>
&lt;h2 id="creating-an-msmq-message-queue">Creating an MSMQ Message Queue&lt;/h2>
&lt;p>After you have installed MSMQ, you can access the control panel for MSMQ by opening &lt;code>Computer Management &amp;gt; Services and Applications &amp;gt; Message Queuing&lt;/code>. From here you can see the four types of queue available within MSMQ as well as the MSMQ triggers (if you installed the triggers):&lt;/p>
&lt;h2 id="accessing-an-msmq-message-queue">Accessing an MSMQ Message Queue&lt;/h2>
&lt;p>In order to access a message queue, you need to add a reference &lt;code>System.Messaging&lt;/code>. This will provide you access to the &lt;code>MessageQueue&lt;/code> class. If you know the path, format name or label you can use &lt;a href="http://msdn.microsoft.com/en-us/library/ch1d814t(v=vs.110).aspx">the following constructor overload&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(pathOrFormatOrLabel);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The path name can be in the following &lt;a href="http://msdn.microsoft.com/en-us/library/ms706083(v=vs.85).aspx">syntax&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;ComputerName\QueueName&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;ComputerName\PRIVATE$\QueueName&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;.\QueueName&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The period shown in the last example is a common computer representation of the local computer.&lt;/p>
&lt;p>In order to reference a queue by its label, the string must start with &lt;code>Label:&lt;/code> followed by the name of the queue. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;Label:TestQueue&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lastly, accessing a queue via its GUID requires the following format `FormatName:Modifier=GUID&amp;quot;, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;FormatName:Public=5A5F7535-AE9A-41d4-935C-845C2AFF7112&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dead letter queues, computer journals and queue journals can all be monitored by using the following paths:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;.\DeadLetter$&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// Non-transactional Dead Letter Queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;.\XactDeadLetter$&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// Transactional Dead Letter Queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;.\Journal$&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// Computer Journal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">@&amp;#34;.\TestQueue\Journal$&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// Queue Journal&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="sending-a-message-to-an-msmq-message-queue">Sending a message to an MSMQ Message Queue&lt;/h2>
&lt;p>In order to send a message to a message queue, you need to know how to access the queue as described above. Next you need to create an instance of the &lt;code>MessageQueue&lt;/code> class using one of the following &lt;a href="http://msdn.microsoft.com/en-us/library/System.Messaging.MessageQueue.MessageQueue(v=vs.110).aspx">MessageQueue constructors&lt;/a>. The &lt;code>MessageQueue&lt;/code> class inherits from Component, which implements &lt;code>IDisposable&lt;/code>, allowing us to cleanly free the resources of the queue by using a &lt;code>using&lt;/code> statement:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the queue has been created, we should check that we can write to the queue by using the &lt;code>CanWrite&lt;/code> property:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanWrite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we cannot write to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can create an instance of the &lt;code>Message&lt;/code> class and call the &lt;code>Send&lt;/code> method on the message queue to send our message:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanWrite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> msg = &lt;span style="color:#66d9ef">new&lt;/span> Message(&lt;span style="color:#e6db74">&amp;#34;Hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mq.Send(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we cannot write to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sending-a-message-to-an-msmq-message-queue-using-transactions">Sending a message to an MSMQ Message Queue using transactions&lt;/h3>
&lt;p>Sometimes we will be required to send messages to a transactional queue. We can extend our previous example to include a check on the &lt;code>Transactional&lt;/code> property:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanWrite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> msg = &lt;span style="color:#66d9ef">new&lt;/span> Message(&lt;span style="color:#e6db74">&amp;#34;Hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.Transactional)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mq.Send(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we cannot write to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here I have branched out the original code into the else branch to compare. Next, we should construct a &lt;code>MessageQueueTransaction&lt;/code> object which in turn can be passed to the &lt;code>Send&lt;/code> method. Before we call the &lt;code>Send&lt;/code> method, we need to ensure that we have called the &lt;code>Begin&lt;/code> method on the transaction object, and &lt;code>Commit&lt;/code> when we have completed. This will ensure that MSMQ will use the correct transactional semantics:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanWrite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> msg = &lt;span style="color:#66d9ef">new&lt;/span> Message(&lt;span style="color:#e6db74">&amp;#34;Hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.Transactional)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> transaction = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueueTransaction();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transaction.Begin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mq.Send(msg, transaction);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transaction.Commit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mq.Send(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we cannot write to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="retrieving-a-message-from-an-msmq-message-queue">Retrieving a message from an MSMQ Message Queue&lt;/h2>
&lt;p>In order to retrieve a message from a message queue, you need to know how to access the queue as described above. Next you need to create an instance of the &lt;code>MessageQueue&lt;/code> class using one of the following &lt;a href="http://msdn.microsoft.com/en-us/library/System.Messaging.MessageQueue.MessageQueue(v=vs.110).aspx">MessageQueue constructors&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the queue has been created, we should check that we can read from the queue by using the &lt;code>CanRead&lt;/code> property:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we can not receive from the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From here, it is a case of calling the &lt;code>Receive&lt;/code> method and processing the result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> msg = mq.Receive();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something with the received message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we can not receive from the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>You may have to set the &lt;code>Formatter&lt;/code> property as shown &lt;a href="http://msdn.microsoft.com/en-us/library/y918yfy2(v=vs.110).aspx">here&lt;/a>.&lt;/em>&lt;/p>
&lt;h3 id="retrieving-a-message-from-an-msmq-message-queue-using-transactions">Retrieving a message from an MSMQ Message Queue using transactions&lt;/h3>
&lt;p>Similarly to the transactional code we used when sending a message, we can inspect the &lt;code>Transactional&lt;/code> property on the &lt;code>MessageQueue&lt;/code> before creating a &lt;code>MessageQueueTransaction&lt;/code> object, passing it to the &lt;code>Receive&lt;/code> method:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>using(&lt;span style="color:#66d9ef">var&lt;/span> mq = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueue(&lt;span style="color:#e6db74">&amp;#34;.\TestQueue&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.CanRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(mq.Transactional)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> transaction = &lt;span style="color:#66d9ef">new&lt;/span> MessageQueueTransaction();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transaction.Begin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mq.Receive(transaction);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transaction.Commit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> msg = mq.Receive();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something with the received message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we can not receive from the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Message Queue Fundamentals: Introduction</title><link>https://im5tu.io/article/2014/09/message-queue-fundementals-introduction/</link><pubDate>Sun, 07 Sep 2014 18:35:37 +0000</pubDate><guid>https://im5tu.io/article/2014/09/message-queue-fundementals-introduction/</guid><description>&lt;p>Message queues are a substantial part of modern day enterprise architectures and a vital part of providing scalable solutions. They are designed for asynchronous communication between different parts of the system. They help scale individual components of a system and increase reliability with the optional addition of the persistence of messages to a storage system.&lt;/p>
&lt;p>In the next few articles I will be covering some of the basics of message queues followed by a couple of different implementations including &lt;a href="http://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx">Microsoft&amp;rsquo;s MSMQ&lt;/a> and &lt;a href="http://particular.net/">Particular&amp;rsquo;s&lt;/a> &lt;a href="http://particular.net/nservicebus">NServiceBus&lt;/a>.&lt;/p>
&lt;h2 id="what-is-a-message-queue-mq">What is a Message Queue (MQ)?&lt;/h2>
&lt;p>Messages queues can be thought of as any other first-in-first-out queue. Each message queue accepts a single message one at a time and stores it until a handler is ready to process this message. If there are no message handlers ready to receive the message, it remains in the queue. Some implementations of message queues allow the configuration of features such as a priority on each message, others do not.&lt;/p>
&lt;p>As mentioned earlier, message queues are designed to perform asynchronous communication which they achieve in one of three principals:&lt;/p>
&lt;ol>
&lt;li>Fire &amp;amp; Forget&lt;/li>
&lt;li>Request-Response&lt;/li>
&lt;li>Publish/Subscribe&lt;/li>
&lt;/ol>
&lt;p>I will also detail a variant of the Request-Response pattern called Scatter-Gather and an additional technique of the Publish/Subscribe pattern called Subscription Filters.&lt;/p>
&lt;h2 id="fire--forget-messaging">Fire &amp;amp; Forget Messaging&lt;/h2>
&lt;p>Originally a military term, the phrase fire and forget has ported well to realms of programming. Typically when two entities are communicating, one entity sends a message and the other replies (be it (a)synchronously). With fire &amp;amp; forget messaging, the entity is not interested in any reply, simply the acknowledgement of the message.&lt;/p>
&lt;p>The best example I can think of is notifications. Once the application server has sent the notification message to the message queue, it is free to process additional requests. When a handler is free to pick up the notification message it does and sends the message on to the relevant device via the correct medium. At any stage during, the only response is acknowledgement of receipt of the notification message. This is so that the queues do not attempt to resend the message. If an error occurs, or a time-out value expires, the message is left in the queue to be tried again, depending on the nature of the error.&lt;/p>
&lt;h2 id="request-reponse-messaging">Request-Reponse Messaging&lt;/h2>
&lt;p>In request-response, two different queues are used; one for processing requests and the other for processing the responses. Whilst sending the message to the request queue, the client often includes a reply address so that a response can be sent to the correct destination.&lt;/p>
&lt;p>Each client typically has its own response queue, so that it only receives responses to its own requests. This pattern of messaging allows the client to continue processing while it waits for a response from the response queue, which would have otherwise been completed via synchronous communication.&lt;/p>
&lt;h3 id="scatter-gather-messaging">Scatter-Gather Messaging&lt;/h3>
&lt;p>Often responses are required from multiple sources. This is where the Scatter-Gather pattern comes in. The Scatter-Gather pattern is a composition of the publish-subcribe pattern that we will see later and the aggregator pattern. Once a message has been published, the subscribers return the responses to a central queue to be consumed by an aggregator.&lt;/p>
&lt;p>The aggregator will know how many responses it should expect, either by using a pre-defined value or via header information. Once the aggregation is complete, the publisher is notified via the response message queue.&lt;/p>
&lt;p>In this scenario, I would typically expect to see three distinct queues:&lt;/p>
&lt;ol>
&lt;li>A publisher queue&lt;/li>
&lt;li>An aggregation queue&lt;/li>
&lt;li>A response queue&lt;/li>
&lt;/ol>
&lt;h2 id="publishsubscribe-messaging">Publish/Subscribe Messaging&lt;/h2>
&lt;p>The publish/subscribe pattern is not to dissimilar to the observer pattern found in C#/Java. Interested parties subscribe to a specific queue in order to receive notifications. Once a message has been sent to the queue, all parties receive a copy of the message.&lt;/p>
&lt;p>This pattern is good for event-driven processing, since components can be added or removed with relative ease. An example would be a users address changes. The changes need to be reflected in the database, a CRM system and a third party provider. Without this pattern, the publisher would have to know about the three different systems in order to complete the processing. Instead, the publisher only knows about the queue, and the queue about the subscribers to that queue.&lt;/p>
&lt;p>A natural extension of this pattern is the &lt;a href="http://msdn.microsoft.com/en-gb/data/gg577609.aspx">Reactive Extensions Framework (Rx)&lt;/a>. It is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators and has been ported to many different languages.&lt;/p>
&lt;h3 id="subscription-filters">Subscription Filters&lt;/h3>
&lt;p>Subscription filters can be applied to any queue that contains a publish-subscribe model. Upon receipt of a message, the queue is responsible for deciding which messages should be sent to each handler. This allows for greater security, because not all subscribers receive all messages, but at the cost of greater processing expense. The addition of each new subscriber will impact the throughput of the queue because the new subscriber has to be considered for every message that flows through the queue.&lt;/p></description></item></channel></rss>