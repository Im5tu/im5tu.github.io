<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>architecture on CodeWithStu's Blog</title><link>https://im5tu.io/tags/architecture/</link><description>Recent content in architecture on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 15 Jul 2020 20:56:00 +0100</lastBuildDate><atom:link href="https://im5tu.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture Pathway Introduction</title><link>https://im5tu.io/article/2020/07/architecture-pathway-introduction/</link><pubDate>Wed, 15 Jul 2020 20:56:00 +0100</pubDate><guid>https://im5tu.io/article/2020/07/architecture-pathway-introduction/</guid><description>&lt;p>Over the past year or so, I&amp;rsquo;ve had the pleasure of mentoring people on their software development journeys. Some of those personnel have expressed a desire to pursue the software architect route. As it&amp;rsquo;s something that I often refer to, I&amp;rsquo;ve decided to post a mini-pathway to help guide on some of the basics.&lt;/p>
&lt;p>The majority of my learnings have come from a mixture of talented people, mistakes and good old fashion practise. The more that you practise designing systems, the better you will become, just like any other skill. I&amp;rsquo;ve included a brief summary from the pages linked so that you can glance at the content as you read along - all credits to their original authors.&lt;/p>
&lt;p>Happy Reading!&lt;/p>
&lt;h2 id="the-10-cloud-architecture-principals">The 10 Cloud Architecture Principals&lt;/h2>
&lt;h3 id="design-for-self-healinghttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesself-healing">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/self-healing">Design for self healing&lt;/a>&lt;/h3>
&lt;p>In a distributed system, failures happen. Hardware can fail. The network can have transient failures. Rarely, an entire service or region may experience a disruption, but even those must be planned for. Therefore, design an application to be self healing when failures occur.&lt;/p>
&lt;h3 id="make-all-things-redundanthttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesredundancy">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/redundancy">Make all things redundant&lt;/a>&lt;/h3>
&lt;p>A resilient application routes around failure. Identify the critical paths in your application. Is there redundancy at each point in the path? If a subsystem fails, will the application fail over to something else?&lt;/p>
&lt;h3 id="mimimize-coordinationhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesminimize-coordination">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/minimize-coordination">Mimimize coordination&lt;/a>&lt;/h3>
&lt;p>Most cloud applications consist of multiple application services — web front ends, databases, business processes, reporting and analysis, and so on. To achieve scalability and reliability, each of those services should run on multiple instances. Coordination between instances limits the benefits of horizontal scale and creates bottlenecks.&lt;/p>
&lt;h3 id="design-to-scale-outhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesscale-out">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/scale-out">Design to scale out&lt;/a>&lt;/h3>
&lt;p>A primary advantage of the cloud is elastic scaling — the ability to use as much capacity as you need, scaling out as load increases, and scaling in when the extra capacity is not needed. Design your application so that it can scale horizontally, adding or removing new instances as demand requires.&lt;/p>
&lt;h3 id="partition-around-limitshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlespartition">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/partition">Partition around limits&lt;/a>&lt;/h3>
&lt;p>In the cloud, all services have limits in their ability to scale up. Limits include number of cores, database size, query throughput, and network throughput. If your system grows sufficiently large, you may hit one or more of these limits. Use partitioning to work around these limits.&lt;/p>
&lt;h3 id="design-for-operationshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesdesign-for-operations">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-operations">Design for operations&lt;/a>&lt;/h3>
&lt;p>The cloud has dramatically changed the role of the operations team. They are no longer responsible for managing the hardware and infrastructure that hosts the application. That said, operations is still a critical part of running a successful cloud application. Involve the operations team in design and planning, to ensure the application gives them the data and insight that need to be successful.&lt;/p>
&lt;h3 id="use-managed-serviceshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesmanaged-services-">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/managed-services">Use managed services&lt;/a>&lt;/h3>
&lt;p>IaaS is like having a box of parts. You can build anything, but you have to assemble it yourself. PaaS options are easier to configure and administer. You don&amp;rsquo;t need to provision VMs, set up VNets, manage patches and updates, and all of the other overhead associated with running software on a VM.&lt;/p>
&lt;h3 id="use-the-best-data-store-for-the-jobhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesuse-the-best-data-store">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/use-the-best-data-store">Use the best data store for the job&lt;/a>&lt;/h3>
&lt;p>In any large solution, it&amp;rsquo;s likely that a single data store technology won&amp;rsquo;t fill all your needs. Alternatives to relational databases include key/value stores, document databases, search engine databases, time series databases, column family databases, and graph databases. Each has pros and cons, and different types of data fit more naturally into one or another.&lt;/p>
&lt;h3 id="design-for-evolutionhttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesdesign-for-evolution">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/design-for-evolution">Design for evolution&lt;/a>&lt;/h3>
&lt;p>All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient. If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system. A change in one part of the application may break another part, or cause changes to ripple through the entire codebase. When services are designed to evolve, teams can innovate and continuously deliver new features.&lt;/p>
&lt;h3 id="build-for-the-needs-of-the-businesshttpsdocsmicrosoftcomen-usazurearchitectureguidedesign-principlesbuild-for-business">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/design-principles/build-for-business">Build for the needs of the business&lt;/a>&lt;/h3>
&lt;p>This design principle may seem obvious, but it&amp;rsquo;s crucial to keep in mind when designing a solution. Do you anticipate millions of users, or a few thousand? Is a one-hour application outage acceptable? Do you expect large bursts in traffic or a predictable workload? Ultimately, every design decision must be justified by a business requirement.&lt;/p>
&lt;h2 id="different-architecture-styles">Different Architecture Styles&lt;/h2>
&lt;h3 id="big-computehttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesbig-compute">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-compute">Big Compute&lt;/a>&lt;/h3>
&lt;p>The term big compute describes large-scale workloads that require a large number of cores, often numbering in the hundreds or thousands. Scenarios include image rendering, fluid dynamics, financial risk modeling, oil exploration, drug design, and engineering stress analysis, among others.&lt;/p>
&lt;h3 id="big-datahttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesbig-data">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/big-data">Big Data&lt;/a>&lt;/h3>
&lt;p>A big data architecture is designed to handle the ingestion, processing, and analysis of data that is too large or complex for traditional database systems. Big data solutions typically involve one or more of the following types of workload:&lt;/p>
&lt;ul>
&lt;li>Batch processing of big data sources at rest.&lt;/li>
&lt;li>Real-time processing of big data in motion.&lt;/li>
&lt;li>Interactive exploration of big data.&lt;/li>
&lt;li>Predictive analytics and machine learning.&lt;/li>
&lt;/ul>
&lt;h3 id="event-drivenhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesevent-driven">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven">Event Driven&lt;/a>&lt;/h3>
&lt;p>An event-driven architecture consists of event producers that generate a stream of events, and event consumers that listen for the events. Events are delivered in near real time, so consumers can respond immediately to events as they occur&lt;/p>
&lt;h3 id="microserviceshttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesmicroservices">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices">Microservices&lt;/a>&lt;/h3>
&lt;p>A microservices architecture consists of a collection of small, autonomous services. Each service is self-contained and should implement a single business capability.&lt;/p>
&lt;h3 id="n-tier-applicationhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesn-tier">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier">N-Tier Application&lt;/a>&lt;/h3>
&lt;p>An N-tier architecture divides an application into logical layers and physical tiers. Layers are a way to separate responsibilities and manage dependencies. Each layer has a specific responsibility. A higher layer can use services in a lower layer, but not the other way around.&lt;/p>
&lt;h3 id="web-queue-workerhttpsdocsmicrosoftcomen-usazurearchitectureguidearchitecture-stylesweb-queue-worker">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/web-queue-worker">Web-queue-worker&lt;/a>&lt;/h3>
&lt;p>The core components of this architecture are a web front end that serves client requests, and a worker that performs resource-intensive tasks, long-running workflows, or batch jobs. The web front end communicates with the worker through a message queue.&lt;/p>
&lt;h2 id="common-design-patterns">Common Design Patterns&lt;/h2>
&lt;h3 id="anti-corruption-layerhttpsdocsmicrosoftcomen-usazurearchitecturepatternsanti-corruption-layer">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer">Anti-corruption layer&lt;/a>&lt;/h3>
&lt;p>Implement a façade or adapter layer between different subsystems that don&amp;rsquo;t share the same semantics. This layer translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an application&amp;rsquo;s design is not limited by dependencies on outside subsystems.&lt;/p>
&lt;h3 id="bulkheadhttpsdocsmicrosoftcomen-usazurearchitecturepatternsbulkhead">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead">Bulkhead&lt;/a>&lt;/h3>
&lt;p>The &lt;a href="https://im5tu.io/article/2022/02/3-ways-to-increase-app-reliability-with-polly/">Bulkhead pattern&lt;/a> is a type of application design that is tolerant of failure. In a bulkhead architecture, elements of an application are isolated into pools so that if one fails, the others will continue to function. It&amp;rsquo;s named after the sectioned partitions (bulkheads) of a ship&amp;rsquo;s hull.&lt;/p>
&lt;h3 id="cache-asidehttpsdocsmicrosoftcomen-usazurearchitecturepatternscache-aside">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">Cache-aside&lt;/a>&lt;/h3>
&lt;p>Load data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.&lt;/p>
&lt;h3 id="circuit-breakerhttpsdocsmicrosoftcomen-usazurearchitecturepatternscircuit-breaker">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">Circuit Breaker&lt;/a>&lt;/h3>
&lt;p>In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections, timeouts, or the resources being over-committed or temporarily unavailable. A circuit breaker handles faults that might take a variable amount of time to recover from, when connecting to a remote service or resource.&lt;/p>
&lt;h3 id="command--query-responsibility-segregationhttpsdocsmicrosoftcomen-usazurearchitecturepatternscqrs">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs">Command &amp;amp; Query Responsibility Segregation&lt;/a>&lt;/h3>
&lt;p>The Command and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.&lt;/p>
&lt;h3 id="compensating-transactionhttpsdocsmicrosoftcomen-usazurearchitecturepatternscompensating-transaction">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction">Compensating Transaction&lt;/a>&lt;/h3>
&lt;p>Undo the work performed by a series of steps, which together define an eventually consistent operation, if one or more of the steps fail. Operations that follow the eventual consistency model are commonly found in cloud-hosted applications that implement complex business processes and workflows.&lt;/p>
&lt;h3 id="competing-consumershttpsdocsmicrosoftcomen-usazurearchitecturepatternscompeting-consumers">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/competing-consumers">Competing Consumers&lt;/a>&lt;/h3>
&lt;p>Enable multiple concurrent consumers to process messages received on the same messaging channel. This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.&lt;/p>
&lt;h3 id="event-sourcinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsevent-sourcing">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">Event Sourcing&lt;/a>&lt;/h3>
&lt;p>Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.&lt;/p>
&lt;h3 id="gatekeeperhttpsdocsmicrosoftcomen-usazurearchitecturepatternsgatekeeper">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/gatekeeper">Gatekeeper&lt;/a>&lt;/h3>
&lt;p>Protect applications and services by using a dedicated host instance that acts as a broker between clients and the application or service, validates and sanitizes requests, and passes requests and data between them. This can provide an additional layer of security, and limit the attack surface of the system.&lt;/p>
&lt;h3 id="leader-electionhttpsdocsmicrosoftcomen-usazurearchitecturepatternsleader-election">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/leader-election">Leader Election&lt;/a>&lt;/h3>
&lt;p>Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure that instances don&amp;rsquo;t conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.&lt;/p>
&lt;h3 id="queue-based-load-levelinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsqueue-based-load-leveling">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling">Queue-Based Load Leveling&lt;/a>&lt;/h3>
&lt;p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.&lt;/p>
&lt;h3 id="retryhttpsdocsmicrosoftcomen-usazurearchitecturepatternsretry">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry">Retry&lt;/a>&lt;/h3>
&lt;p>Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation. This can improve the stability of the application.&lt;/p>
&lt;h3 id="shardinghttpsdocsmicrosoftcomen-usazurearchitecturepatternssharding">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sharding">Sharding&lt;/a>&lt;/h3>
&lt;p>Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.&lt;/p>
&lt;h3 id="sidecarhttpsdocsmicrosoftcomen-usazurearchitecturepatternssidecar">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar">Sidecar&lt;/a>&lt;/h3>
&lt;p>Deploy components of an application into a separate process or container to provide isolation and encapsulation. This pattern can also enable applications to be composed of heterogeneous components and technologies.&lt;/p>
&lt;h3 id="stranglerhttpsdocsmicrosoftcomen-usazurearchitecturepatternsstrangler">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler">Strangler&lt;/a>&lt;/h3>
&lt;p>Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system&amp;rsquo;s features, strangling the old system and allowing you to decommission it.&lt;/p>
&lt;h3 id="throttlinghttpsdocsmicrosoftcomen-usazurearchitecturepatternsthrottling">&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/throttling">Throttling&lt;/a>&lt;/h3>
&lt;p>Control the consumption of resources used by an instance of an application, an individual tenant, or an entire service. This can allow the system to continue to function and meet service level agreements, even when an increase in demand places an extreme load on resources.&lt;/p>
&lt;h2 id="distributed-systems-theory">Distributed Systems Theory&lt;/h2>
&lt;h3 id="understanding-the-8-fallacies-of-distributed-systemshttpswwwsimpleorientedarchitecturecom8-fallacies-of-distributed-systems">&lt;a href="https://www.simpleorientedarchitecture.com/8-fallacies-of-distributed-systems/">Understanding the 8 fallacies of Distributed Systems&lt;/a>&lt;/h3>
&lt;p>More than 20 years ago Peter Deutsch and James Gosling defined the 8 fallacies of distributed computing. These are false assumptions that many developers make about distributed systems. These are usually proven wrong in the long run, leading to hard to fix bugs.&lt;/p>
&lt;h3 id="cap-theoremhttpsrobertgreinercomcap-theorem-revisited">&lt;a href="https://robertgreiner.com/cap-theorem-revisited/">CAP Theorem&lt;/a>&lt;/h3>
&lt;p>The CAP Theorem states that, in a distributed system (a collection of interconnected nodes that share data.), you can only have two out of the following three guarantees across a write/read pair: Consistency, Availability, and Partition Tolerance - one of them must be sacrificed.&lt;/p>
&lt;h3 id="how-sharding-workshttpsmediumcomjeeyoungkhow-sharding-works-b4dec46b3f6">&lt;a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">How Sharding Works&lt;/a>&lt;/h3>
&lt;p>Your application suddenly becomes popular. Traffic and data is starting to grow, and your database gets more overloaded every day. People on the internet tell you to scale your database by sharding, but you don’t really know what it means. You start doing some research, and run into this post.&lt;/p>
&lt;h3 id="consistent-hashinghttpwwwtom-e-whitecom200711consistent-hashinghtml">&lt;a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html">Consistent Hashing&lt;/a>&lt;/h3>
&lt;p>The need for consistent hashing arose from limitations experienced while running collections of caching machines - web caches, for example. If you have a collection of n cache machines then a common way of load balancing across them is to put object o in cache machine number hash(o) mod n.&lt;/p>
&lt;h2 id="other-interesting-reads">Other Interesting Reads&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/">Workload Isolation Using Shuffle-Sharding&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/avoiding-insurmountable-queue-backlogs/">Avoiding Insurmountable Queue Backlogs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/builders-library/implementing-health-checks/">Implementing Health Checks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@SkyscannerEng/monoliths-and-microservices-8c65708c3dbf">Monoliths and Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a">Fault Tolerance in a High Volume, Distributed System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@NetflixTechBlog/tips-for-high-availability-be0472f2599c">Tips for High Availability&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://technology.riotgames.com/news/globalizing-player-accounts">Globalizing Player Accounts while Maintaining Availability&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f">Microservice Architecture at Medium&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://architecht.io/lessons-from-facebook-on-engineering-for-scale-f5716f0afc7a">Automate and abstract: Lessons from Facebook on engineering for scale&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Domain Driven Design Notes</title><link>https://im5tu.io/article/2017/05/domain-driven-design-notes/</link><pubDate>Wed, 24 May 2017 16:25:48 +0100</pubDate><guid>https://im5tu.io/article/2017/05/domain-driven-design-notes/</guid><description>&lt;p>&lt;em>These are my notes on domain driven design whilst watching the course by Dino Esposito on &lt;a href="https://app.pluralsight.com/library/courses/modern-software-architecture-domain-models-cqrs-event-sourcing/table-of-contents">Pluralsight&lt;/a>.&lt;/em>&lt;/p>
&lt;p>Domain Driven Design (or DDD), is the process of discovering both data and behavioural requirements for a given problem domain where traditional approaches usually focus purely on data collection aspects. The aim is to provide better tools to tackle the complexity at the heart of software.&lt;/p>
&lt;p>Within DDD, there are two distinct parts: an analytical one and a strategical one. To use a DDD centric approach, the analytical aspects are required while the strategical aspects can take one of many forms depending on the requirements gained from analytical insight.&lt;/p>
&lt;h2 id="analytical">Analytical&lt;/h2>
&lt;p>The analytical aspect of DDD is useful for everyone and every project undertaken because it describes the domain in which you are working, using a common set of language. The common set of language used is called ubiquitous language within DDD jargon. These aspects of DDD are key in a couple of main areas:&lt;/p>
&lt;ul>
&lt;li>When there is a lot of domain logic that can be tricky to digest:
&lt;ul>
&lt;li>No synonyms for same/similar concepts;&lt;/li>
&lt;li>Ensures all terms are understood&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Or, the business logic is not completely defined:
&lt;ul>
&lt;li>Business is young (eg: startup);&lt;/li>
&lt;li>Logic is discovered on the way&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ubiquitous-language">Ubiquitous Language&lt;/h3>
&lt;p>The aim of ubiquitous language is to avoid misunderstandings and assumptions by creating business centric terminology shared by all members of a project, both technical and non-technical. Once defined, the language should used universally in spoken and written communication, avoiding synonym creation which breeds ambiguity and misunderstanding.&lt;/p>
&lt;p>Ubiquitous language is itteratively composed throughout interviews and brainstorming sessions using the natural language of the business, not creating new expressions for pre-existing concepts. The language will continually evolve over time, so it is important that updates are communicated across the business to reflect the understanding of the domain. It should neither be purely from domain experts nor technical experts. However, the ubiquitous language may contain some technical language to ensure clarity and consistency.&lt;/p>
&lt;p>Acronyms are widely used across many business sectors that are hard to remember and understand. Where possible, acronyms should be avoided, being replaced by words that retain the same meaning of the acronym. This makes the language easier to use and understand for all parties involved. The language, although continually evolving, should not be continuly stretched as this will create a bloated, less regirous language than intended.&lt;/p>
&lt;p>Lastly, the language used should be agnostic to all technology and paradigms. Moreover, when naming elements of code, the names should be reflective of the language used ensuring that concepts above are adhered to (eg: no acronyms/no synonyms).&lt;/p>
&lt;h3 id="bounded-contexts">Bounded Contexts&lt;/h3>
&lt;p>Bounded contexts are areas of the domain in which an element has a unique, unambiguous, well-defined meaning. Outside the boundries of a given bounded context, the ubiquitous language changes. If the meaning behind the language is same, the context should be the same. Each bounded context may have it&amp;rsquo;s own unique architecture and implementation. Moreover, each bounded context should have a well defined external interface so that it can be consumed from other bounded contexts.&lt;/p>
&lt;p>This concept was introduced into DDD to help with the following problems:&lt;/p>
&lt;ul>
&lt;li>Remove ambiguity and duplication from within ubiquitous language;&lt;/li>
&lt;li>Simplify design of software modules;&lt;/li>
&lt;li>Help to integrate legacy software tools and components.&lt;/li>
&lt;/ul>
&lt;p>Within a given business domain, you may often find that the same term is used but with different meanings. When this occurs, it is a signal that the business domain should be split into multiple bounded contexts. However, these new contexts are not completely isolated as they are often connected through the way they communicate and interact with one another. Typically, the number of bounded contexts often reflects the physical organisation/department structure of the business.&lt;/p>
&lt;h3 id="context-maps">Context Maps&lt;/h3>
&lt;p>The overall layout of bounded contexts within a business domain can be represented on a context map, as shown below:&lt;/p>
&lt;p>&lt;img src="https://miro.medium.com/v2/resize:fit:1103/0*Dig5eOh00vMkqOiw.jpg" alt="Example DDD Context Map">&lt;/p>
&lt;p>On the image above, there are a few new terms to understand:&lt;/p>
&lt;ul>
&lt;li>U &amp;amp; D or Upstream/Downstream:
&lt;ul>
&lt;li>Upstream/Downstream shows the direction of the relationship between bounded contexts&lt;/li>
&lt;li>Upstream influences downstreams context and is available as a reference to the downstream context&lt;/li>
&lt;li>Downstream is simply a consumer of the upstream context but cannot influence it&amp;rsquo;s work directly (eg: change composition)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Conformist:
&lt;ul>
&lt;li>Indicates that the downstream context completely depends on the upstream context (eg: when the upstream context is a legacy system/external service)&lt;/li>
&lt;li>Typically no neogation of changes is possible&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Customer/Supplier:
&lt;ul>
&lt;li>Indicates that the downstream context is dependent on the upstream context&lt;/li>
&lt;li>Negotiation of changes between the customer/supplier is possible and the customer can usually expect the changes to be made in some way&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Partner:
&lt;ul>
&lt;li>Indicates a mutual dependency between two bounded contexts&lt;/li>
&lt;li>Changes are negotiated between both teams&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACL or Anti-Corruption Layer:
&lt;ul>
&lt;li>Fixed contract at the boundry of the bounded context&lt;/li>
&lt;li>Allows for internal changes without affecting consumers; so is most helpful when dealing with external API&amp;rsquo;s&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="event-storming">Event Storming&lt;/h3>
&lt;p>Event Storming, originally developed by Alberto Brandolini, is an emerging practise to explore the business domain and identify key events and commands. The practise involves getting technical and domain experts together in a room to build a timeline of events and commands, draw sketches and make notes which helps to result in the following:
- Comprehensive vision of the business domain
- Identification of bounded contexts and aggregates in each context
- Types of users in the system (who runs commands and why)
- Identification of where UX is critical&lt;/p>
&lt;p>Usually, a long whiteboard is used to note down the observable events on the time line, ideally with colour identification (eg: sticky notes). With coloured sticky notes, you would typically have a single colour for events and a different colour for commands (etc). This aids in the visual representation of the domain and the flows throughout.&lt;/p>
&lt;p>The number of people in the meeting, should ideally not break the two pizza rule. The meeting should be kept on track through the presence of a facilitator, whos job it is to prevent long running discussions and guides the modeling effort. The facilitator doesn&amp;rsquo;t necessarily have to be a domain expert but this might be useful to get the meeting started.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Two pizza rule&lt;/strong>: Never have a meeting where two pizzas couldn&amp;rsquo;t feed the entire group&lt;/p>
&lt;/blockquote></description></item></channel></rss>