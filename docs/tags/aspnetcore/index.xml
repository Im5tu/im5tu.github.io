<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>aspnetcore on CodeWithStu's Blog</title><link>https://im5tu.io/tags/aspnetcore/</link><description>Recent content in aspnetcore on CodeWithStu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 01 Jan 2024 16:00:00 +0000</lastBuildDate><atom:link href="https://im5tu.io/tags/aspnetcore/index.xml" rel="self" type="application/rss+xml"/><item><title>The Smartest Way to Onboard Developers</title><link>https://im5tu.io/video/the-smartest-way-to-onboard-developers/</link><pubDate>Mon, 01 Jan 2024 16:00:00 +0000</pubDate><guid>https://im5tu.io/video/the-smartest-way-to-onboard-developers/</guid><description>&lt;p>Change happens. People will leave your team and people join your team. But what if there was an easy way to get new people up to speed in minutes, not weeks. Imagine clippy could hold your hand through a code base which you can easily refer back to at any time. The best bit? Anyone can do this.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/pUzFZKVlPtk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="video-links">Video Links&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/microsoft/codetour">CodeTours Repository&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=vsls-contrib.codetour">CodeTours Extension&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/marketplace/actions/codetour-watch">CodeTour Watch Action&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://plugins.jetbrains.com/plugin/19227-codetour">CodeTour Plugin For IntelliJ IDEs&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>The Way You Publish Apps Is Changing | .NET 7</title><link>https://im5tu.io/video/the-way-you-publish-apps-is-changing-net-7/</link><pubDate>Tue, 15 Nov 2022 13:00:00 +0000</pubDate><guid>https://im5tu.io/video/the-way-you-publish-apps-is-changing-net-7/</guid><description>&lt;p>Go from zero to docker image in 30 seconds! In this video, we&amp;rsquo;re going to discuss the changes that are happening with publishing apps in .NET 7. I&amp;rsquo;ll show you how to make the changes backwards compatible with .NET 6 and how to customize your experience.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/a88szDQ1AEo" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="video-links">Video Links&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=6USQ3_81wQM">.NET 7: 10 New Features You Need to Know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/dotnet/sdk-container-builds">SDK Container Builds Repo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V5wJeN3Ntqc">How to make your csproj settings available via NuGet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ubuntu.com/blog/install-dotnet-on-ubuntu">Ubuntu Chiselled Docker Images&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Mocking APIs Made Easy with Mockaco</title><link>https://im5tu.io/video/mocking-apis-made-easy-with-mockaco/</link><pubDate>Fri, 07 Oct 2022 07:00:14 +0100</pubDate><guid>https://im5tu.io/video/mocking-apis-made-easy-with-mockaco/</guid><description>&lt;p>Mockaco is an HTTP-based dotnet API mocking server with fast setup - great for when you need to setup a mock API to test locally. As Mockaco is also a docker image, we can utilize this in our build pipelines to get some confidence in our tests without requiring external dependencies.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/QBnXCgZFzM0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="video-links">Video Links&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/natenho/Mockaco">Mockaco&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Ad7wruPBp3M">Testing like a PRO with XUnit &amp;amp; Localstack - .NET 7&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>ASP.NET Core Versioning: Minimal APIs</title><link>https://im5tu.io/article/2022/10/asp.net-core-versioning-minimal-apis/</link><pubDate>Tue, 04 Oct 2022 12:00:00 +0100</pubDate><guid>https://im5tu.io/article/2022/10/asp.net-core-versioning-minimal-apis/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/YRJGKyzjFlY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>This blog post is also available as a video on my &lt;a href="https://codewithstu.tv">YouTube Channel&lt;/a>.&lt;/em>&lt;/p>
&lt;p>If your API is a key part of your product you are going to want to version your APIs. One of the major reasons that we consider versioning our api’s is so that we provide a consistent experience for our users. If we consistently change our API’s then our consumers will break, they will get annoyed and eventually leave our product.&lt;/p>
&lt;p>There are three main ways that you can version your API’s:&lt;/p>
&lt;ul>
&lt;li>Headers&lt;/li>
&lt;li>Querystring&lt;/li>
&lt;li>Urls&lt;/li>
&lt;/ul>
&lt;p>I don’t believe there is a right way to do versioning, so I am going to show you all three approaches in this article and let you decide which one is best for your scenario. The article specifically looks at ASP.NET Core Minimal APIs. For MVC APIs, go &lt;a href="https://im5tu.io/article/2022/09/asp.net-core-versioning-mvc-apis/">here&lt;/a>.&lt;/p>
&lt;h2 id="versioning-setup">Versioning Setup&lt;/h2>
&lt;p>Depending on whether we are working with Minimal APIs or MVC depends on which NuGet package we need to add. For MVC based APIs we need to add the &lt;code>Asp.Versioning.Http&lt;/code> package from NuGet.&lt;/p>
&lt;p>It’s worth noting that the name of this package has changed from the previous &lt;code>Microsoft.AspNetCore.Mvc.Versioning&lt;/code> package because the main contributor to the repository has now left Microsoft and can’t reuse the Microsoft prefix. You can read more about this &lt;a href="https://github.com/dotnet/aspnet-api-versioning/discussions/807">here&lt;/a>.&lt;/p>
&lt;p>Once we’ve add the correct NuGet package for our API type, we can head over to our service collection and call &lt;code>AddApiVersioning&lt;/code> - we will want the options later on, so I’m going to setup that lambda function now:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning.Conventions;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> version1 = &lt;span style="color:#66d9ef">new&lt;/span> ApiVersion(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> version2 = &lt;span style="color:#66d9ef">new&lt;/span> ApiVersion(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> builder = WebApplication.CreateBuilder(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We will change this later on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> app = builder.Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.Run();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="versioning-strategy">Versioning Strategy&lt;/h2>
&lt;p>One minor thing that you need to consider before you is what style of versioning numbers you’re going to have. For example, I use a major only strategy in which I use a single number to describe a version, eg: v1. Another common versioning strategy is to use a major/minor setup, eg: 1.0.&lt;/p>
&lt;p>You’ll also need to consider how much a version covers for an API. For me, I have versioning setup on a per endpoint basis, but I have also seen all endpoints on an API be versioned as one.&lt;/p>
&lt;p>There is no right strategy for you to pick here, it all depends on your requirements and what you think is easiest for you to manage vs the experience for your consumers. For the rest of this article, I am going to use my standard setup of major-only versioning on a per endpoint basis.&lt;/p>
&lt;h2 id="adding-versions-to-minimal-apis">Adding versions to Minimal APIs&lt;/h2>
&lt;p>The setup for a minimal API is a bit different to what we would normally do in the MVC world. First we need to create a version set which tells the API versioning subsystem which versions are available to be used. Here we can set some common options like whether to report API Versions or not:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> app = builder.Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> versionSet = app.NewApiVersionSet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .HasApiVersion(version1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .HasApiVersion(version2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From there we are versioning each endpoint by first calling &lt;code>WithApiVersionSet&lt;/code> passing in our version set, before either mapping it to a specific version with &lt;code>MapToApiVersion&lt;/code> or making it version agnostic with &lt;code>.IsApiVersionNeutral()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.WithApiVersionSet(versionSet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.HasApiVersions(&lt;span style="color:#66d9ef">new&lt;/span> [] {version1, version2});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this setup is done, for the most part, the api versioning setup is exactly the same in terms of where to get the api version from.&lt;/p>
&lt;h2 id="versioning-via-headers">Versioning via Headers&lt;/h2>
&lt;p>The first way that we can read the version of the request is to use headers. When using a header, we have two approaches that we can use:&lt;/p>
&lt;ul>
&lt;li>We can use an extension to the Accept header&lt;/li>
&lt;li>Or we can use a custom header&lt;/li>
&lt;/ul>
&lt;p>To use the media type we use the options we created earlier to add in:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> MediaTypeApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/media-header.png" alt="Verification in Postman using the Accept header">&lt;/p>
&lt;p>To use a custom header such as &lt;code>X-Api-Version&lt;/code> we need to change the ApiVersionReader to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> HeaderApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;X-Api-Version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/custom-header.png" alt="Verification in Postman using the Custom header">&lt;/p>
&lt;h2 id="versioning-via-querystrings">Versioning via QueryStrings&lt;/h2>
&lt;p>The next way of versioning our urls is to use a querystring parameter. Here we will change the type of ApiVersionReader to &lt;code>QueryStringApiVersionReader&lt;/code> and pass in the name of the parameter that we will use as part of the querystring to provide the version information:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> QueryStringApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/querystring.png" alt="Verification in Postman using a querystring">&lt;/p>
&lt;h2 id="versioning-via-urls">Versioning via URLs&lt;/h2>
&lt;p>The last major way of adding in versioning information is to use URLs. To add the version information to the URL we need to modify the route itself. Instead of changing an attribute like we would in MVC, we just need to edit the route information passed into MapGet, MapPut etc. We put in the new path segment in the exact same way as we did for the MVC route segements, ie: we add a new segment to our URL called &lt;code>version&lt;/code> limited to the type &lt;code>apiVersion&lt;/code>. This is a special validation that’s created by the versioning package to ensure that correct values are passed in and the correct actions are called:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>app.MapGet(&lt;span style="color:#e6db74">&amp;#34;v{version:apiVersion}/weather&amp;#34;&lt;/span>, (HttpContext context) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> apiVersion = context.GetRequestedApiVersion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + apiVersion?.MajorVersion?.ToString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.WithApiVersionSet(versionSet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.HasApiVersions(&lt;span style="color:#66d9ef">new&lt;/span> [] {version1, version2});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this is setup for your application, the last bit that we need to do is change the ApiVersionReader in the versioning options. We use the type &lt;code>UrlSegementApiVersionReader&lt;/code> to make the package read from the route data instead.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> UrlSegmentApiVersionReader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="https://im5tu.io/img/api-versioning/url.png" alt="Verification in Postman using a route parameter">&lt;/p>
&lt;h2 id="other-versioning-options">Other versioning options&lt;/h2>
&lt;p>There are other things that we can do with this package such as specifying the default version when one is not specified and reporting the supported and deprecated versions in our responses.&lt;/p>
&lt;p>To set the default version, we would set the option &lt;code>AssumeDefaultVersionWhenUnspecified&lt;/code> to &lt;code>true&lt;/code> and then &lt;code>DefaultApiVersion&lt;/code> to the default version that you wish to be assumed. Note, that this will only work if you are using the header or querystring versioning strategies.&lt;/p>
&lt;p>We can also specify which versions are depreciated and which ones are not. There’s slightly different ways of doing this. In MVC APIs we would set the deprecated flag on the ApiVersion attribute that we decorate our controllers and actions with. For minimal APIs we call &lt;code>HasDepecatedApiVersion&lt;/code> with the relevant version number on the version set that we are using. Once this is done, for both MVC and Minimal APIs we set &lt;code>ReportApiVersions&lt;/code> equal to true in the options and start getting the headers &lt;code>api-deprecated-versions&lt;/code> and &lt;code>api-supported-versions&lt;/code> returned as part of responses. These headers contain a comma separated list of supported versions.&lt;/p>
&lt;p>&lt;em>The full code for this is available to my &lt;a href="https://github.com/sponsors/im5tu">Github Sponsors&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>ASP.NET Core Versioning: MVC APIs</title><link>https://im5tu.io/article/2022/09/asp.net-core-versioning-mvc-apis/</link><pubDate>Fri, 30 Sep 2022 12:00:00 +0100</pubDate><guid>https://im5tu.io/article/2022/09/asp.net-core-versioning-mvc-apis/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/YRJGKyzjFlY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>This blog post is also available as a video on my &lt;a href="https://codewithstu.tv">YouTube Channel&lt;/a>.&lt;/em>&lt;/p>
&lt;p>If your API is a key part of your product you are going to want to version your APIs. One of the major reasons that we consider versioning our api’s is so that we provide a consistent experience for our users. If we consistently change our API’s then our consumers will break, they will get annoyed and eventually leave our product.&lt;/p>
&lt;p>There are three main ways that you can version your API’s:&lt;/p>
&lt;ul>
&lt;li>Headers&lt;/li>
&lt;li>Querystring&lt;/li>
&lt;li>Urls&lt;/li>
&lt;/ul>
&lt;p>I don’t believe there is a right way to do versioning, so I am going to show you all three approaches in this article and let you decide which one is best for your scenario. The article specifically looks at ASP.NET Core MVC APIs.&lt;/p>
&lt;h2 id="versioning-setup">Versioning Setup&lt;/h2>
&lt;p>Depending on whether we are working with Minimal APIs or MVC depends on which NuGet package we need to add. For MVC based APIs we need to add the &lt;code>Asp.Versioning.Mvc&lt;/code> package from NuGet.&lt;/p>
&lt;p>It’s worth noting that the name of this package has changed from the previous &lt;code>Microsoft.AspNetCore.Mvc.Versioning&lt;/code> package because the main contributor to the repository has now left Microsoft and can’t reuse the Microsoft prefix. You can read more about this &lt;a href="https://github.com/dotnet/aspnet-api-versioning/discussions/807">here&lt;/a>.&lt;/p>
&lt;p>Once we’ve add the correct NuGet package for our API type, we can head over to our service collection and call &lt;code>AddApiVersioning&lt;/code> - we will want the options later on, so I’m going to setup that lambda function now:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Asp.Versioning.Conventions;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> builder = WebApplication.CreateBuilder(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>builder.Services.AddControllers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We will fill this in later on&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.AddMvc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> app = builder.Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.MapControllers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.Run();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The call to &lt;code>AddMvc&lt;/code> at the end of &lt;code>AddApiVersioning&lt;/code> is extremely important as without it, MVC does not know how to link the versioning information.&lt;/p>
&lt;h2 id="versioning-strategy">Versioning Strategy&lt;/h2>
&lt;p>One minor thing that you need to consider before you is what style of versioning numbers you’re going to have. For example, I use a major only strategy in which I use a single number to describe a version, eg: v1. Another common versioning strategy is to use a major/minor setup, eg: 1.0.&lt;/p>
&lt;p>You’ll also need to consider how much a version covers for an API. For me, I have versioning setup on a per endpoint basis, but I have also seen all endpoints on an API be versioned as one.&lt;/p>
&lt;p>There is no right strategy for you to pick here, it all depends on your requirements and what you think is easiest for you to manage vs the experience for your consumers. For the rest of this article, I am going to use my standard setup of major-only versioning on a per endpoint basis.&lt;/p>
&lt;h2 id="adding-versions-to-mvc-controllers">Adding versions to MVC controllers&lt;/h2>
&lt;p>With a controller, we can add the version information either at the class level meaning that the api version will apply to all of the actions in that controller (and any derived implementations) as well versioning a specific action.&lt;/p>
&lt;p>To version an entire controller, add the attribute &lt;code>ApiVersion&lt;/code> passing in the version that you want:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiController]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion( 1.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion( 2.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Route(&amp;#34;weather&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WeatherController&lt;/span> : ControllerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet, MapToApiVersion( 2.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> GetV2( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To version a single endpoint, add the same &lt;code>ApiVersion&lt;/code> attribute and version number to endpoint you want versioned:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiController]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Route(&amp;#34;weather&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WeatherController&lt;/span> : ControllerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet, ApiVersion( 1.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet, ApiVersion( 2.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> GetV2( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In order to depreciate a version we can use a parameter on the &lt;code>ApiVersion&lt;/code> attribute called &lt;code>Deprecated&lt;/code> to tell our users/documentation that a specific version of an API has been deprecated:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiController]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion(1.0, Depreciated = true)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion(2.0)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Route(&amp;#34;weather&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WeatherController&lt;/span> : ControllerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet, MapToApiVersion( 2.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> GetV2( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="versioning-via-headers">Versioning via Headers&lt;/h2>
&lt;p>The first way that we can read the version of the request is to use headers. When using a header, we have two approaches that we can use:&lt;/p>
&lt;ul>
&lt;li>We can use an extension to the Accept header&lt;/li>
&lt;li>Or we can use a custom header&lt;/li>
&lt;/ul>
&lt;p>To use the media type we use the options we created earlier to add in:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> MediaTypeApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="media-header.png" alt="Verification in Postman using the Accept header">&lt;/p>
&lt;p>To use a custom header such as &lt;code>X-Api-Version&lt;/code> we need to change the ApiVersionReader to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> HeaderApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;X-Api-Version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="custom-header.png" alt="Verification in Postman using the Custom header">&lt;/p>
&lt;h2 id="versioning-via-querystrings">Versioning via QueryStrings&lt;/h2>
&lt;p>The next way of versioning our urls is to use a querystring parameter. Here we will change the type of ApiVersionReader to &lt;code>QueryStringApiVersionReader&lt;/code> and pass in the name of the parameter that we will use as part of the querystring to provide the version information:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> QueryStringApiVersionReader(&lt;span style="color:#e6db74">&amp;#34;version&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="querystring.png" alt="Verification in Postman using a querystring">&lt;/p>
&lt;h2 id="versioning-via-urls">Versioning via URLs&lt;/h2>
&lt;p>The last major way of adding in versioning information is to use URLs. To add the version information to the URL we need to modify the route itself. Depending on your setup, this might be via the &lt;code>Route&lt;/code> attribute or via the one of the &lt;code>HTTP&lt;/code> attributes like &lt;code>HTTPGet&lt;/code>. We add a new segment to our URL called &lt;code>version&lt;/code> limited to the type &lt;code>apiVersion&lt;/code>. This is a special validation that’s created by the versioning package to ensure that correct values are passed in and the correct actions are called.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiController]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion(1.0)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[ApiVersion(2.0)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Route(&amp;#34;v{version:apiVersion}/weather&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WeatherController&lt;/span> : ControllerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet, MapToApiVersion( 2.0 )]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> GetV2( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this is setup for your application, the last bit that we need to do is change the ApiVersionReader in the versioning options. We use the type &lt;code>UrlSegementApiVersionReader&lt;/code> to make the package read from the route data instead.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>builder.Services.AddApiVersioning(options =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options.ApiVersionReader = &lt;span style="color:#66d9ef">new&lt;/span> UrlSegmentApiVersionReader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can verify this in postman:&lt;/p>
&lt;p>&lt;img src="url.png" alt="Verification in Postman using a route parameter">&lt;/p>
&lt;h2 id="accessing-versioning-information">Accessing Versioning Information&lt;/h2>
&lt;p>For any of the versioning strategies that we’ve just been through, we may come across scenarios where we need to access the version that’s been requested by the user. One way to access this information is to go through the HTTPContext.&lt;/p>
&lt;p>On each HTTP Context instance there is an extension method that we can invoke called &lt;code>GetRequestedApiVersion&lt;/code>. If there is a version requested by the user, the method returns this as a &lt;code>ApiVersion&lt;/code> instance, otherwise it returns null:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get() =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + Context.GetRequestedApiVersion()?.ToString();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Alternatively, for we can inject the version as a parameter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[HttpGet]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Get( ApiVersion version ) =&amp;gt; &lt;span style="color:#e6db74">&amp;#34;Version &amp;#34;&lt;/span> + version;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="other-versioning-options">Other versioning options&lt;/h2>
&lt;p>There are other things that we can do with this package such as specifying the default version when one is not specified and reporting the supported and deprecated versions in our responses.&lt;/p>
&lt;p>To set the default version, we would set the option &lt;code>AssumeDefaultVersionWhenUnspecified&lt;/code> to &lt;code>true&lt;/code> and then &lt;code>DefaultApiVersion&lt;/code> to the default version that you wish to be assumed. Note, that this will only work if you are using the header or querystring versioning strategies.&lt;/p>
&lt;p>We can also specify which versions are depreciated and which ones are not. There’s slightly different ways of doing this. In MVC APIs we would set the deprecated flag on the ApiVersion attribute that we decorate our controllers and actions with. For minimal APIs we call &lt;code>HasDepecatedApiVersion&lt;/code> with the relevant version number on the version set that we are using. Once this is done, for both MVC and Minimal APIs we set &lt;code>ReportApiVersions&lt;/code> equal to true in the options and start getting the headers &lt;code>api-deprecated-versions&lt;/code> and &lt;code>api-supported-versions&lt;/code> returned as part of responses. These headers contain a comma separated list of supported versions.&lt;/p>
&lt;p>&lt;em>The full code for this is available to my &lt;a href="https://github.com/sponsors/im5tu">Github Sponsors&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>Pro Testing with Xunit &amp; Localstack</title><link>https://im5tu.io/article/2022/09/pro-testing-with-xunit-localstack/</link><pubDate>Sun, 25 Sep 2022 12:00:00 +0100</pubDate><guid>https://im5tu.io/article/2022/09/pro-testing-with-xunit-localstack/</guid><description>&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/Ad7wruPBp3M" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>This blog post is also available as a video on my &lt;a href="https://codewithstu.tv">YouTube Channel&lt;/a>.&lt;/em>&lt;/p>
&lt;p>Ever wondered how to get docker images to run nicely with XUnit tests? Then you&amp;rsquo;re in the right place. Let me show you how to setup &lt;a href="https://localstack.cloud">Localstack&lt;/a> with XUnit properly so that the only thing you need to worry about is having docker running. I&amp;rsquo;m using Localstack as the example but you can repeat a very similar process using the techniques shown here.&lt;/p>
&lt;p>We will first setup the base infrastructure using two lesser known XUnit features before doing container management using &lt;a href="https://github.com/testcontainers/testcontainers-dotnet">TestContainers&lt;/a>.&lt;/p>
&lt;h2 id="our-test-case">Our Test Case&lt;/h2>
&lt;p>To verify that we have everything working as we expect later on, I have the following test case which will require that a table be created with a specific name. If we do everything correctly, then this test should pass.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Amazon.DynamoDBv2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CustomTests&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _localstackServiceUrl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CustomTests()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackServiceUrl = &lt;span style="color:#e6db74">&amp;#34;http://localhost:4566&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [Fact(Timeout = 30000)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task UsingLocalstack_ViaTestContainers()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Arrange&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> client = &lt;span style="color:#66d9ef">new&lt;/span> AmazonDynamoDBClient(&lt;span style="color:#66d9ef">new&lt;/span> AmazonDynamoDBConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceURL = _localstackServiceUrl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Act&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> tables = &lt;span style="color:#66d9ef">await&lt;/span> client.ListTablesAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Assert&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.True(tables.TableNames.Count == &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">$&amp;#34;Incorrect table count found. Expected 1, found: {tables.TableNames.Count}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.True(tables.TableNames[&lt;span style="color:#ae81ff">0&lt;/span>] == &lt;span style="color:#e6db74">&amp;#34;localstack-test&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">$&amp;#34;Table name mismatch. Expected &amp;#39;localstack-test&amp;#39; found: {tables.TableNames[0]}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="xunit-features">Xunit Features&lt;/h2>
&lt;h3 id="iasynclifetime">IAsyncLifetime&lt;/h3>
&lt;p>The first feature that of XUnit that we are going to take a look at is lifecycle management with &lt;code>IAsyncLifetime&lt;/code>. We’re going to use this to create an instance of a Localstack container later on, but we need to setup a class initially to use it with our second XUnitFeature. When we add this interface to a class, we tell XUnit that it needs to start and dispose of this implementation in an asynchronous manner. This means that we need to implement two methods:&lt;/p>
&lt;ul>
&lt;li>&lt;code>InitializeAsync&lt;/code>&lt;/li>
&lt;li>&lt;code>DisposeAsync&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>So lets create a class called &lt;code>LocalstackContainer&lt;/code> and stub out the methods for us to complete later on:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> DotNet.Testcontainers.Builders;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> DotNet.Testcontainers.Configurations;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> DotNet.Testcontainers.Containers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LocalstackContainer&lt;/span> : IAsyncLifetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task InitializeAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Implement later&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task DisposeAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Implement later&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> ToAbsolute(&lt;span style="color:#66d9ef">string&lt;/span> path) =&amp;gt; Path.GetFullPath(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="collection-fixtures">Collection Fixtures&lt;/h3>
&lt;p>The next feature of XUnit we are going to rely on is Collection Fixtures. This allows us to have a singleton instance of an object for all tests unlike a &lt;code>ClassFixture&lt;/code> which only allows us to have a singleton instance for test that inherit from the class fixture. The reason I am opt-ing for a collection fixture is so that we reduce the number instances of the localstack container because it can be quite heavy to run. If you think you can get away with a regular class fixture for your project you can definitely do that.&lt;/p>
&lt;p>A collection fixture needs three parts:&lt;/p>
&lt;ul>
&lt;li>A class for the collection definition&lt;/li>
&lt;li>Adding an attribute to the test class pointing to the collection definition&lt;/li>
&lt;li>Injecting the class instance into the test class&lt;/li>
&lt;/ul>
&lt;p>Let’s take a look at the collection definition first. XUnit needs this for discovery purposes and requires us to do two things to our class:&lt;/p>
&lt;ul>
&lt;li>Inherit from &lt;code>ICollectionFixture&amp;lt;T&amp;gt;&lt;/code> - where &lt;code>T&lt;/code> is the type you want a singleton of, in our case we want &lt;code>Localstackcontainer&lt;/code> which is the type we created earlier&lt;/li>
&lt;li>Next we need to add a class level attribute &lt;code>CollectionDefinition&lt;/code> which requires us to supply a name. For simplicity i’m going to use the &lt;code>nameof&lt;/code> expression to point back to our &lt;code>T&lt;/code>:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[CollectionDefinition(nameof(LocalstackContainer))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LocalstackContainerInstanceCollectionFixture&lt;/span> : ICollectionFixture&amp;lt;LocalstackContainer&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that’s for the collection definition. If we move across to our test class now, where I have already pre-populated this with a random test that will ensure that everything is working later on.&lt;/p>
&lt;p>To make use of the collection definition we need to add a class level attribute called &lt;code>Collection&lt;/code> and pass in the same name that we gave to the &lt;code>CollectionDefinition&lt;/code> attribute on the previous class. So here we will use the same &lt;code>nameof&lt;/code> expression so that everything lines up nicely for us.&lt;/p>
&lt;p>The last bit is to create a new constructor in our test class and add a parameter for our new type - which for us is going to be our localstack container.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Collection(nameof(LocalstackContainer))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CustomTests&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _localstackServiceUrl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CustomTests(LocalstackContainer containerInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackServiceUrl = &lt;span style="color:#e6db74">&amp;#34;http://localhost:4566&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// omitted for brevity&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So at this point, we have a XUnit all configured to use a single instance of a container class that has an asynchronous lifetime managed for us. Let’s start spinning up a docker container…&lt;/p>
&lt;h2 id="localstack-container-instance-with-testcontainers">Localstack Container Instance with TestContainers&lt;/h2>
&lt;h3 id="setup">Setup&lt;/h3>
&lt;p>If you haven’t heard of test containers before, you really need to go and check the project out. We are going to use TestContainers to spin up a new instance of localstack in our tests using the localstack container class that we created earlier. First up, lets create two properties, one for the localstack port that we’re going to use and the next for a generated URL using the new port number just to make our lives a bit easier later on.&lt;/p>
&lt;p>We then need to create a private field to hold the container so we can implement the lifecycle events later on:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LocalstackContainer&lt;/span> : IAsyncLifetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> TestcontainersContainer _localstackContainer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> LocalstackPort { &lt;span style="color:#66d9ef">get&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> LocalstackUri =&amp;gt; &lt;span style="color:#e6db74">$&amp;#34;http://localhost:{LocalstackPort}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// omitted for brevity&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the constructor is where we are going to create the container definition. We create a new instance of &lt;code>TestcontainersBuilder&lt;/code> with the type &lt;code>TestcontainersContainer&lt;/code> from which we can configure this container. We need to call a few methods on this instance:&lt;/p>
&lt;ul>
&lt;li>WithImage - tells us which docker image to use&lt;/li>
&lt;li>WithCleanUp - tells TestContainers to clean up the image when we are done with it&lt;/li>
&lt;li>WithPortBinding - maps the ports for us. It’s important that we use the generated port number here mapping back to the localstack port of 4566.&lt;/li>
&lt;li>WithWaitStrategy - is used to tell us to wait for the port to become available. We’ll come back to this later.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> LocalstackContainer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Randomise the port to prevent port errors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalstackPort = Random.Shared.Next(&lt;span style="color:#ae81ff">4000&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackContainer = &lt;span style="color:#66d9ef">new&lt;/span> TestcontainersBuilder&amp;lt;TestcontainersContainer&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithImage(&lt;span style="color:#e6db74">&amp;#34;localstack/localstack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithCleanUp(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithPortBinding(LocalstackPort, &lt;span style="color:#ae81ff">4566&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once that’s all done, we can then build the container definition. Next we need to go and configure the lifecycle events to start and stop our container:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task InitializeAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> var cts = &lt;span style="color:#66d9ef">new&lt;/span> CancellationTokenSource(TimeSpan.FromMinutes(&lt;span style="color:#ae81ff">5&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> _localstackContainer.StartAsync(cts.Token);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task DisposeAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> _localstackContainer.DisposeAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the &lt;code>InitializeAsync&lt;/code> method, we first need to create a new &lt;code>CancellationTokenSource&lt;/code> so that we can abort any slow start ups if we need to. Then we call &lt;code>StartAsync&lt;/code> on the container instance we setup earlier, remembering to pass in the cancellation token.&lt;/p>
&lt;p>In the &lt;code>DisposeAsync&lt;/code> method, we just need to call &lt;code>DisposeAsync&lt;/code> on the TestContainers instance.&lt;/p>
&lt;p>Before we can test this, we need to ensure that we update our tests to look at the new localstack URL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Collection(nameof(LocalstackContainer))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CustomTests&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _localstackServiceUrl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CustomTests(LocalstackContainer containerInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackServiceUrl = containerInstance.LocalstackUri;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// omitted for brevity&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With this now done, we are in a suitable point where we can test the entire flow and watch our docker container spin up and teardown without any effort other than clicking run on the tests. The test will still fail at this point, but the lifecycle of our docker image is now managed.&lt;/p>
&lt;h3 id="seeding-data-in-localstack">Seeding data in Localstack&lt;/h3>
&lt;p>Now that we have a container up and running, we want the ability to to seed it with something useful, such as data for a dynamodb table. In order to do this, we need to change our container configuration a bit.&lt;/p>
&lt;p>We are going to create two directories for our data:&lt;/p>
&lt;ul>
&lt;li>aws-seed-data: which will hold our initialization script and our next directory:&lt;/li>
&lt;li>scripts: this is where the bulk of your scripts will go&lt;/li>
&lt;/ul>
&lt;p>Under the &lt;code>aws-seed-data&lt;/code> directory, create a new file called &lt;code>init.sh&lt;/code> ensuring that the line endings are set to &lt;code>LF&lt;/code> only. This file will help us control the ordering and invocation of sub-scripts later on.&lt;/p>
&lt;p>Next under the scripts sub-directory, create a new script called &lt;code>dynamodb.sh&lt;/code>. In here we are going to create a new dynamo db table using the &lt;code>awslocal&lt;/code> command. This command is essentially a fully fledged AWS CLI but you never have to set the endpoint, which makes it super handy for scripting. In my example here, I’m just creating a dynamo table as I would normally, just switch &lt;code>aws&lt;/code> for &lt;code>awslocal&lt;/code>. Although I’m not doing it here, you can do a lot of fancy things like pre-seeding the dynamo table with a set amount of data for example.&lt;/p>
&lt;p>&lt;img src="folder-structure.png" alt="Desired Folder Structure">&lt;/p>
&lt;p>Inside of our init script, we need to have the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/scripts/dynamodb.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that the forward slash at the start is very important as your just about to see.&lt;/p>
&lt;p>Inside of our &lt;code>dynamodb.sh&lt;/code> script, we need to have the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>awslocal dynamodb create-table &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --table-name localstack-test &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --key-schema AttributeName&lt;span style="color:#f92672">=&lt;/span>PartitionKey,KeyType&lt;span style="color:#f92672">=&lt;/span>HASH AttributeName&lt;span style="color:#f92672">=&lt;/span>SortKey,KeyType&lt;span style="color:#f92672">=&lt;/span>RANGE &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --attribute-definitions AttributeName&lt;span style="color:#f92672">=&lt;/span>PartitionKey,AttributeType&lt;span style="color:#f92672">=&lt;/span>S AttributeName&lt;span style="color:#f92672">=&lt;/span>SortKey,AttributeType&lt;span style="color:#f92672">=&lt;/span>S &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --provisioned-throughput ReadCapacityUnits&lt;span style="color:#f92672">=&lt;/span>10,WriteCapacityUnits&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we now head back to our localstack container instance, we need to adjust the setup to mount our new seeding files. To do this we need the full path on the host that we want to mount and its corresponding destination in the docker image.&lt;/p>
&lt;p>Localstack has a special folder in the image which is used to look for scripts at different parts of the initialization process - called &lt;code>/etc/localstack/init&lt;/code> - this folder contains 4 directories:&lt;/p>
&lt;ul>
&lt;li>&lt;code>boot.d&lt;/code>: Scripts that run whenthe container is running but the LocalStack runtime has not been started&lt;/li>
&lt;li>&lt;code>start.d&lt;/code>: Scripts that run when the Python process is running and the LocalStack runtime is starting&lt;/li>
&lt;li>&lt;code>ready.d&lt;/code>: Scripts that run when LocalStack is ready to serve requests&lt;/li>
&lt;li>&lt;code>shutdown.d&lt;/code>: Scripts that run when LocalStack is shutting down&lt;/li>
&lt;/ul>
&lt;p>We are going to mount the folder containing our &lt;code>init.sh&lt;/code> script to the &lt;code>ready.d&lt;/code> directory - so once localstack is ready it will execute that script. To do this, we call &lt;code>WithBindMount&lt;/code> on the container image, passing in our folder followed by the folder in the docker image:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> LocalstackContainer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalstackPort = Random.Shared.Next(&lt;span style="color:#ae81ff">4000&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackContainer = &lt;span style="color:#66d9ef">new&lt;/span> TestcontainersBuilder&amp;lt;TestcontainersContainer&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithImage(&lt;span style="color:#e6db74">&amp;#34;localstack/localstack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithCleanUp(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithPortBinding(LocalstackPort, &lt;span style="color:#ae81ff">4566&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithBindMount(ToAbsolute(&lt;span style="color:#e6db74">&amp;#34;./localstack/aws-seed-data&amp;#34;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;/etc/localstack/init/ready.d&amp;#34;&lt;/span>, AccessMode.ReadOnly)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithBindMount(ToAbsolute(&lt;span style="color:#e6db74">&amp;#34;./localstack/aws-seed-data/scripts&amp;#34;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;/scripts&amp;#34;&lt;/span>, AccessMode.ReadOnly)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We also need to map our scripts directory, so again we need to call &lt;code>WithBindMount&lt;/code> and map the scripts directory to &lt;code>/scripts&lt;/code>&lt;/p>
&lt;h3 id="health-check-wait-strategy">Health check wait strategy&lt;/h3>
&lt;p>With our container now seeded, we have a slight ordering problem. Our tests may execute before our localstack instance has been fully provisioned. Luckily for us, both TestContainers and Localstack has us covered here.&lt;/p>
&lt;p>Localstack has an endpoint that we can call to check the status of the initialization. This is located on the endpoint &lt;code>_localstack/init/ready&lt;/code>.&lt;/p>
&lt;p>TestContainers allows us to provide our own wait strategy too - so we can use that to create a new wait check by implementing the &lt;code>IWaitUntil&lt;/code> class.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LocalstackContainerHealthCheck&lt;/span> : IWaitUntil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _endpoint;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> LocalstackContainerHealthCheck(&lt;span style="color:#66d9ef">string&lt;/span> endpoint)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _endpoint = endpoint;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the constructor of the wait check, we need to take a single parameter which is going to be the endpoint that localstack will be listening on. In the &lt;code>Until&lt;/code> method we need to make a quick call to the API. The structure of the json returned has a &lt;code>completed&lt;/code> object that has keys for each of the initialization phases. It also has a scripts section which contains a list of scripts for each stage and their corresponding states. We just need to look for the &lt;code>init.sh&lt;/code> script in &lt;code>READY&lt;/code> stage and ensure that it has the state &lt;code>SUCCESSFUL&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Until(ITestcontainersContainer testcontainers, ILogger logger)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// https://github.com/localstack/localstack/pull/6716&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> var httpClient = &lt;span style="color:#66d9ef">new&lt;/span> HttpClient { BaseAddress = &lt;span style="color:#66d9ef">new&lt;/span> Uri(_endpoint) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode? result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="color:#66d9ef">await&lt;/span> httpClient.GetFromJsonAsync&amp;lt;JsonNode&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;/_localstack/init/ready&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> scripts = result[&lt;span style="color:#e6db74">&amp;#34;scripts&amp;#34;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (scripts &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> script &lt;span style="color:#66d9ef">in&lt;/span> scripts.Deserialize&amp;lt;IEnumerable&amp;lt;Script&amp;gt;&amp;gt;() ?? Enumerable.Empty&amp;lt;Script&amp;gt;())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#e6db74">&amp;#34;READY&amp;#34;&lt;/span>.Equals(script.Stage, StringComparison.OrdinalIgnoreCase))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#e6db74">&amp;#34;init.sh&amp;#34;&lt;/span>.Equals(script.Name, StringComparison.OrdinalIgnoreCase))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SUCCESSFUL&amp;#34;&lt;/span>.Equals(script.State, StringComparison.OrdinalIgnoreCase);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">Script&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [property: JsonPropertyName(&amp;#34;stage&amp;#34;)]&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Stage,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [property: JsonPropertyName(&amp;#34;state&amp;#34;)]&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> State,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [property: JsonPropertyName(&amp;#34;name&amp;#34;)]&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The last bit for us to do is to configure the wait strategy for the container. In the container definition, we need to call a method called &lt;code>WithWaitStrategy&lt;/code>. This takes one or more wait strategies which are built using the &lt;code>Wait&lt;/code> class. The first thing we need to do here is tell Testcontainers that we are going to be waiting for a linux container by calling &lt;code>Wait.ForUnixContainer&lt;/code> - then we can add two additional methods:&lt;/p>
&lt;ul>
&lt;li>&lt;code>UntilPortIsAvailable&lt;/code> - which will check the linux container to ensure that a port is being listened on. This will always need to be the container port, so in our case localstack’s port of 4566, not the randomised port we created earlier.&lt;/li>
&lt;li>&lt;code>AddCustomWaitStrategy&lt;/code> - which we need to pass in a new instance of our new wait strategy&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> LocalstackContainer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalstackPort = Random.Shared.Next(&lt;span style="color:#ae81ff">4000&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _localstackContainer = &lt;span style="color:#66d9ef">new&lt;/span> TestcontainersBuilder&amp;lt;TestcontainersContainer&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithImage(&lt;span style="color:#e6db74">&amp;#34;localstack/localstack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithCleanUp(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithPortBinding(LocalstackPort, &lt;span style="color:#ae81ff">4566&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithWaitStrategy(Wait.ForUnixContainer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .UntilPortIsAvailable(&lt;span style="color:#ae81ff">4566&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .AddCustomWaitStrategy(&lt;span style="color:#66d9ef">new&lt;/span> LocalstackContainerHealthCheck(LocalstackUri))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithBindMount(ToAbsolute(&lt;span style="color:#e6db74">&amp;#34;./localstack/aws-seed-data&amp;#34;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;/etc/localstack/init/ready.d&amp;#34;&lt;/span>, AccessMode.ReadOnly)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WithBindMount(ToAbsolute(&lt;span style="color:#e6db74">&amp;#34;./localstack/aws-seed-data/scripts&amp;#34;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;/scripts&amp;#34;&lt;/span>, AccessMode.ReadOnly)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With all of these steps completed, you should now have tests that are nice and repeatable using XUnit and Localstack! If you’re wondering what else you’re missing out on, check out some of the &lt;a href="https://www.youtube.com/watch?v=6USQ3_81wQM">latest features in .NET 7 you may have missed&lt;/a>.&lt;/p>
&lt;p>&lt;em>The full code for this is available to my &lt;a href="https://github.com/sponsors/im5tu">Github Sponsors&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>How To Version ASP.NET Core MVC &amp; Minimal APIs</title><link>https://im5tu.io/video/how-to-version-asp-net-core-mvc-minimal-apis/</link><pubDate>Tue, 13 Sep 2022 05:45:01 +0100</pubDate><guid>https://im5tu.io/video/how-to-version-asp-net-core-mvc-minimal-apis/</guid><description>&lt;p>Versioning API&amp;rsquo;s can be extremely important for your product. Learn 4 different ways to version your APIs in .NET minimal APIs and .NET MVC APIs. The techniques you&amp;rsquo;ll learn are: content type negotiation versioning, custom headers versioning, query string versioning and URL versioning.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/YRJGKyzjFlY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="video-links">Video Links&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/dotnet/aspnet-api-versioning/discussions/807">Update to Versioning Package&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.google.com/blog/products/api-management/api-design-which-version-of-versioning-is-right-for-you">API Version Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.troyhunt.com/your-api-versioning-is-wrong-which-is">Your API Versioning Is Wrong&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Using PASETO in .NET - #shorts</title><link>https://im5tu.io/video/using-paseto-in-net-shorts/</link><pubDate>Thu, 18 Aug 2022 22:44:48 +0100</pubDate><guid>https://im5tu.io/video/using-paseto-in-net-shorts/</guid><description>&lt;p>For the full video, go here: &lt;a href="https://www.youtube.com/watch?v=oNQdDjvS_54">https://www.youtube.com/watch?v=oNQdDjvS_54&lt;/a>&lt;/p>
&lt;p>Creating a restricted file download with S3 is easy with pre-signed URLs. But what your endpoint isn&amp;rsquo;t a file? Or you&amp;rsquo;re not sourcing it from S3? In this video, we take a look at an upcoming technology called PASETO (platform agnostic security token) and see how to create an endpoint that is restricted by time.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/I9vaRNujs8o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>A New Way to Create Time Restricted Endpoints in .NET</title><link>https://im5tu.io/video/a-new-way-to-create-time-restricted-endpoints-in-net/</link><pubDate>Mon, 15 Aug 2022 06:00:23 +0100</pubDate><guid>https://im5tu.io/video/a-new-way-to-create-time-restricted-endpoints-in-net/</guid><description>&lt;p>Creating a restricted file download with S3 is easy with pre-signed URLs. But what your endpoint isn&amp;rsquo;t a file? Or you&amp;rsquo;re not sourcing it from S3? In this video, we take a look at an upcoming technology called PASETO (platform agnostic security token) and see how to create an endpoint that is restricted by time.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/oNQdDjvS_54" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Implementing Simple Feature Toggles In AspNetCore Using IConfiguration</title><link>https://im5tu.io/article/2020/08/implementing-simple-feature-toggles-in-aspnetcore-using-iconfiguration/</link><pubDate>Sat, 29 Aug 2020 11:45:00 +0100</pubDate><guid>https://im5tu.io/article/2020/08/implementing-simple-feature-toggles-in-aspnetcore-using-iconfiguration/</guid><description>&lt;p>Recently, we&amp;rsquo;ve had the need to build a few feature toggles in our applications that can be changed at runtime. This article walks through a simple approach that you can use in your applications, including a description of a route to dynamic feature toggles.&lt;/p>
&lt;p>We&amp;rsquo;ve built out our feature toggle system on top of the &lt;code>IConfiguration&lt;/code> in ASP.NET Core as we do not need anything particularly fancyand we already have the packages referenced in our applications. If we needed something more advanced, we would take a look into one of the many available packages. If you just need something simple, you&amp;rsquo;re in the right place.&lt;/p>
&lt;p>If you already know what feature toggles are and you&amp;rsquo;re familiar with the configuration model in ASP.NET Core, jump straight to &lt;a href="#building-out-simple-feature-toggles-using-iconfiguration">Building out simple feature toggles using IConfiguration&lt;/a>.&lt;/p>
&lt;h2 id="what-are-feature-toggles">What are feature toggles?&lt;/h2>
&lt;p>Also known as feature flags, feature toggles are a technique in software development to enable certain functionality in an application. Typically this happens when releasing new functionality to consumers, but can also be used to sunset features or provide a global on/off switch (for example).&lt;/p>
&lt;h2 id="configuration-system-in-net-core">Configuration System in .NET Core&lt;/h2>
&lt;p>Since the beginning of .NET Core, the ASP.NET team has rebuilt the &lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1">configuration&lt;/a> and &lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1">options&lt;/a> system to provide a decent abstraction that can be used inside and outside of ASP.NET Core. The configuration is provided by the &lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Configuration">Microsoft.Extensions.Configuration&lt;/a> NuGet package. This package takes care of the &amp;ldquo;how do I locate my settings&amp;rdquo; part of the problem by providing an simple &lt;code>IConfiguration&lt;/code> abstraction.&lt;/p>
&lt;p>The second part of the problem is accessing the configuration, which is where the &lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1">options model&lt;/a> comes into play. The &lt;a href="https://www.nuget.org/packages/Microsoft.Extensions.Options">Microsoft.Extensions.Options&lt;/a> package gives us abstractions to retrieve configuration from the &lt;code>IConfiguration&lt;/code> abstraction the configuration model provides, while providing hooks for validation and post-configuration.&lt;/p>
&lt;p>Both the configuration and options packages are included by default when building out an ASP.NET core application. For service workers, you may need to install these packages manually.&lt;/p>
&lt;h2 id="building-out-simple-feature-toggles-using-iconfiguration">Building out simple feature toggles using IConfiguration&lt;/h2>
&lt;p>In order to build a simple feature toggle system, we first need a class that will hold our feature toggles:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FeatureToggles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> MyFirstToggle { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, we need to add a new configuration source to our host builder which tells the application where we should look for our configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>Host.CreateDefaultBuilder()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ConfigureAppConfiguration(builder =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Adds environment variables prefixed with STU_TEST&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Note: the prefix will be removed from the environment variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.AddEnvironmentVariables(&lt;span style="color:#e6db74">&amp;#34;STU_TEST&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .Run();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So long as the configuration provider you added supports the updating of a feature flag, it can be changed at runtime from an external source like &lt;a href="https://www.consul.io/">consul&lt;/a>, or even within your application itself. When we have our configuration source configured, we need to tell our application how to link a configuration section to the &lt;code>FeatureToggles&lt;/code> class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Startup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IConfiguration Configuration { &lt;span style="color:#66d9ef">get&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Startup(IConfiguration configuration) { Configuration = configuration; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> ConfigureServices(IServiceCollection services)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// May require you to include Microsoft.Extensions.Configuration.Binder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> services.Configure&amp;lt;FeatureToggles&amp;gt;(Configuration.GetSection(&lt;span style="color:#e6db74">&amp;#34;FeatureToggles&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the sample above, we have injected the application configuration into the startup class so that we can access all of the configuration that has built because we need access to the &lt;code>FeatureToggles&lt;/code> section of that configuration. The only bit that is left is to access the configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SampleController&lt;/span> : ControllerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> FeatureToggles _featureToggles;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SampleController(IOptionsSnapshot&amp;lt;FeatureToggles&amp;gt; featureToggles)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _featureToggles = featureToggles.Value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [HttpGet(&amp;#34;/my-first-toggle&amp;#34;)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IActionResult MyFirstToggle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Ok(&lt;span style="color:#e6db74">$&amp;#34;The value of MyFirstToggle is: {_featureToggles.MyFirstToggle}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we now submit a request to &lt;code>/my-first-toggle&lt;/code> we should now see the current value returned to us as part of the response. When consuming the options from a scoped context, eg: a http request, ensure to always use &lt;code>IOptionsSnapshot&amp;lt;T&amp;gt;&lt;/code> (or &lt;code>IOptionsMonitor&amp;lt;T&amp;gt;&lt;/code> if snapshot is not possible - but check the documentation to view the differences) as this ensures consistency for the settings in that scope and has some additional performance benefits.&lt;/p>
&lt;p>That&amp;rsquo;s it, simple feature toggles. Happy Toggling!&lt;/p></description></item><item><title>Diagnostics in .Net Core 3: Listening to inbound HTTP requests</title><link>https://im5tu.io/article/2020/06/diagnostics-in-.net-core-3-listening-to-inbound-http-requests/</link><pubDate>Fri, 19 Jun 2020 14:00:00 +0000</pubDate><guid>https://im5tu.io/article/2020/06/diagnostics-in-.net-core-3-listening-to-inbound-http-requests/</guid><description>&lt;p>In my &lt;a href="https://im5tu.io/article/2020/06/diagnostics-in-.net-core-3-listening-to-outbound-http-requests/">previous article&lt;/a> we took a look at how to monitor outbound HTTP requests using a &lt;code>DiagnosticListener&lt;/code>. In this article, we will re-use some of the same components to monitor inbound HTTP requests. We could use middleware to do as most approaches do, but this approach is highly dependent on the middleware that you have and the duration of this, so we will re-use some of the code from last time.&lt;/p>
&lt;p>A lot of this article relies on the infrastructure that we built out previously, so if something is missing here, it will likely be in that article. We will need to implement the following components:&lt;/p>
&lt;ol>
&lt;li>A new DiagnosticListener&lt;/li>
&lt;li>A observer that looks at incoming requests&lt;/li>
&lt;li>A observer that looks at the response&lt;/li>
&lt;li>A metric builder that builds our diagnostic counters&lt;/li>
&lt;/ol>
&lt;h2 id="implementing-the-diagnosticlistener">Implementing the DiagnosticListener&lt;/h2>
&lt;p>In order to hook into the infrastructure that we built in the previous article, we need a new implementation of &lt;code>DiagnosticListenerBase&lt;/code> that listens on the &lt;code>Microsoft.AspNetCore DiagnosticSource&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InboundHttpRequestDiagnosticListener&lt;/span> : DiagnosticListenerBase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> List&amp;lt;IInboundHttpObserver&amp;gt; _observers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> _name = &lt;span style="color:#e6db74">&amp;#34;Microsoft.AspNetCore&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> InboundHttpRequestDiagnosticListener(IEnumerable&amp;lt;IInboundHttpObserver&amp;gt; observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _observers = observers.ToList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> TryObserve(DiagnosticListener diagnosticListener)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (diagnosticListener &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> || !diagnosticListener.Name.Equals(_name, StringComparison.OrdinalIgnoreCase))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> observer &lt;span style="color:#66d9ef">in&lt;/span> _observers)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Subscribe(diagnosticListener, observer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The intention here is that we only subscribe specific observers when we encounter a &lt;code>DiagnosticListener&lt;/code> that’s named &lt;code>Microsoft.AspNetCore&lt;/code>. This listener has two specific events that we need to listen for:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Microsoft.AspNetCore.Hosting.BeginRequest&lt;/code> - Contains the following properties: httpContext, timestamp&lt;/li>
&lt;li>&lt;code>Microsoft.AspNetCore.Hosting.EndRequest&lt;/code> - Contains the following properties: httpContext, timestamp&lt;/li>
&lt;/ul>
&lt;p>We will bind all of our observers into our IoC container again so that we can take advantage of injecting dependencies easily should we want/need to. The code is near identical to the outbound version otherwise.&lt;/p>
&lt;h2 id="implementing-the-observers">Implementing the observers&lt;/h2>
&lt;p>The approach we are going to take is largely the same as the outbound HTTP requests. The &lt;code>DiagnosticListener&lt;/code> that we subscribe to is different, as are the payloads, but we get a near identical set of information that we can use to generate out metrics. As per the previous article, we use a marker interface for all of our inbound observers, which is declared as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">IInboundHttpObserver&lt;/span> : IObserver&amp;lt;KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">object&lt;/span>&amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="implementing-the-request-observer">Implementing the request observer&lt;/h3>
&lt;p>The purpose of the &lt;code>InboundHttpRequestObserver&lt;/code> is to extract the timestamp property that’s contained in the &lt;code>Microsoft.AspNetCore.Hosting.BeginRequest&lt;/code> event, which indicates the ticks that the request started, and attach this as a property in the &lt;code>HttpContext&lt;/code> so that we can access it later on.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InboundHttpRequestObserver&lt;/span> : SimpleDiagnosticListenerObserver, IInboundHttpObserver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnNext(KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">object&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.Key == &lt;span style="color:#e6db74">&amp;#34;Microsoft.AspNetCore.Hosting.BeginRequest&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> data = GetValueAs&amp;lt;TypedData&amp;gt;(&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data?.httpContext?.Items &lt;span style="color:#66d9ef">is&lt;/span> {})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data.httpContext.Items[&lt;span style="color:#e6db74">&amp;#34;RequestTimestamp&amp;#34;&lt;/span>] = data.timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TypedData&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> HttpContext? httpContext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Like our outbound implementation, I&amp;rsquo;ve generated a typed class so that we can access the data within the events payload as these are internal classes. I’ve nested a class inside of the observer to help with this, containing only the properties that I need.&lt;/p>
&lt;h3 id="implementing-the-response-observer">Implementing the response observer&lt;/h3>
&lt;p>The purpose of the &lt;code>InboundHttpResponseObserver&lt;/code> is to extract the timestamp property that’s contained in the &lt;code>Microsoft.AspNetCore.Hosting.EndRequest&lt;/code> event, which indicates the ticks that the request finished, and calculate the duration using the request timestamp that we previously stored in the &lt;code>HttpContext&lt;/code> properties.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InboundHttpResponseObserver&lt;/span> : SimpleDiagnosticListenerObserver, IInboundHttpObserver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> IInboundHttpMetricBuilder _metricBuilder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> InboundHttpResponseObserver(IInboundHttpMetricBuilder metricBuilder)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metricBuilder = metricBuilder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> OnNext(KeyValuePair&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">object&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.Key == &lt;span style="color:#e6db74">&amp;#34;Microsoft.AspNetCore.Hosting.EndRequest&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> data = GetValueAs&amp;lt;TypedData&amp;gt;(&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">object?&lt;/span> requestTimestamp = &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data.httpContext?.Items?.TryGetValue(&lt;span style="color:#e6db74">&amp;#34;RequestTimestamp&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">out&lt;/span> requestTimestamp) == &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (requestTimestamp &lt;span style="color:#66d9ef">is&lt;/span> {} &amp;amp;&amp;amp; &lt;span style="color:#66d9ef">long&lt;/span>.TryParse(requestTimestamp?.ToString(), &lt;span style="color:#66d9ef">out&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> startTimestamp))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> response = data.httpContext.Response;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> request = data.httpContext.Request;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// For all HTTP requests we should:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// - Track the success (&amp;lt;400 status code response) or failure of the API call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// - Capture the latency of the request&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> resultCounter = (&lt;span style="color:#66d9ef">int&lt;/span>)response.StatusCode &amp;lt; &lt;span style="color:#ae81ff">400&lt;/span> ? _metricBuilder.GetSuccessCounter(request, response) : _metricBuilder.GetErrorCounter(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resultCounter?.Increment();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _metricBuilder.GetLatencyCounter(request, response)?.WriteMetric(GetDuration(startTimestamp, data.timestamp).TotalMilliseconds);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TypedData&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> HttpContext? httpContext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As mentioned in a previous section, I&amp;rsquo;ve generated a typed class so that we can access the data within the events payload. I’ve nested a class inside of the observer to help with this, containing only the properties that I need. Now that we have all of the data we need to generate some metrics, we can use the injected &lt;code>IInboundHttpMetricBuilder&lt;/code> to create the metrics that we want to track dynamically.&lt;/p>
&lt;h2 id="creating-metrics-from-the-context-of-the-request">Creating metrics from the context of the request&lt;/h2>
&lt;p>In our services, there are a few bits of information that I want to capture about the context of the request:&lt;/p>
&lt;ol>
&lt;li>Whether the request was successful or not (based on the HTTP Status code)&lt;/li>
&lt;li>The duration of the request, in milliseconds&lt;/li>
&lt;/ol>
&lt;p>With this information, we want to add metadata to the DiagnosticCounters that we generate so that we can use it as dimensions in our monitoring applications like DataDog/Prometheus. We want to track the following properties:&lt;/p>
&lt;ul>
&lt;li>HTTP method: GET/POST/PUT/PATCH/DELETE etc&lt;/li>
&lt;li>HTTP version: 1.0/1.1/2.0 etc&lt;/li>
&lt;li>HTTP scheme: HTTP/HTTPS&lt;/li>
&lt;li>HTTP request type: outbound (previous article)/inbound (this article)&lt;/li>
&lt;li>HTTP status code: 200/201/202/204/400 etc&lt;/li>
&lt;li>Request Path: /search&lt;/li>
&lt;li>Host: &amp;lt;www.google.com&amp;gt;&lt;/li>
&lt;/ul>
&lt;p>With this information, we should have more than enough to filter out specific flows easily, whilst being able to aggregate the results where needed. Each one of the properties is added to each one of the diagnostic counters that we generate:&lt;/p>
&lt;ul>
&lt;li>Success Counter&lt;/li>
&lt;li>Error Counter&lt;/li>
&lt;li>Latency Counter&lt;/li>
&lt;/ul>
&lt;p>To allow us to override the implementation later on, we can use the following interface:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">IInboundHttpMetricBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IncrementingEventCounter? GetSuccessCounter(HttpRequest request, HttpResponse response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IncrementingEventCounter? GetErrorCounter(HttpRequest request, HttpResponse response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EventCounter? GetLatencyCounter(HttpRequest request, HttpResponse response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Note:&lt;/strong> &lt;em>For a summary of the different types of event counters, please see &lt;a href="https://im5tu.io/article/2020/01/diagnostics-in-.net-core-3-event-counters/">this article&lt;/a>.&lt;/em>&lt;/p>
&lt;p>In order to generate the same tags that we want, we can start of with the exact same code from the previous article. We can re-use most of the same code from the previous article, renaming anything that says &lt;code>outbound&lt;/code> to &lt;code>inbound&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DefaultInboundHttpMetricBuilder&lt;/span> : IInboundHttpMetricBuilder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, IncrementingEventCounter&amp;gt; _successCounters = &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, IncrementingEventCounter&amp;gt;(&lt;span style="color:#66d9ef">new&lt;/span> ListOfTupleEqualityComparer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, IncrementingEventCounter&amp;gt; _errorCounters = &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, IncrementingEventCounter&amp;gt;(&lt;span style="color:#66d9ef">new&lt;/span> ListOfTupleEqualityComparer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, EventCounter&amp;gt; _latencyCounters = &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, EventCounter&amp;gt;(&lt;span style="color:#66d9ef">new&lt;/span> ListOfTupleEqualityComparer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IncrementingEventCounter GetSuccessCounter(HttpRequest request, HttpResponse response) =&amp;gt; GetCoreHttpRequestCounter(_successCounters, request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> IncrementingEventCounter GetErrorCounter(HttpRequest request, HttpResponse response) =&amp;gt; GetCoreHttpRequestCounter(_errorCounters, request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> EventCounter GetLatencyCounter(HttpRequest request, HttpResponse response)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> _latencyCounters.GetOrAdd(GetCoreTags(request, response), key =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> counter = &lt;span style="color:#66d9ef">new&lt;/span> EventCounter(&lt;span style="color:#e6db74">&amp;#34;http-request-latency&amp;#34;&lt;/span>, CheckoutEventSource.Instance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DisplayName = &lt;span style="color:#e6db74">&amp;#34;HTTP Request Latency&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DisplayUnits = &lt;span style="color:#e6db74">&amp;#34;ms&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> dimension &lt;span style="color:#66d9ef">in&lt;/span> key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter.AddMetadata(dimension.key, dimension.&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CheckoutEventSource.Instance.AddDiagnosticCounter(counter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> counter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> IncrementingEventCounter GetCoreHttpRequestCounter(ConcurrentDictionary&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt;, IncrementingEventCounter&amp;gt; collection, HttpRequest request, HttpResponse response)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> collection.GetOrAdd(GetCoreTags(request, response), key =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Debug.WriteLine(&lt;span style="color:#e6db74">&amp;#34;CREATED NEW COUNTER: &amp;#34;&lt;/span> + &lt;span style="color:#66d9ef">string&lt;/span>.Join(&lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>, key.Select(x =&amp;gt; &lt;span style="color:#e6db74">$&amp;#34;{x.key}:{x.value}&amp;#34;&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> counter = &lt;span style="color:#66d9ef">new&lt;/span> IncrementingEventCounter(&lt;span style="color:#e6db74">&amp;#34;http-request&amp;#34;&lt;/span>, CheckoutEventSource.Instance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DisplayName = &lt;span style="color:#e6db74">&amp;#34;HTTP Request Count&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DisplayUnits = &lt;span style="color:#e6db74">&amp;#34;requests&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> dimension &lt;span style="color:#66d9ef">in&lt;/span> key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter.AddMetadata(dimension.key, dimension.&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CheckoutEventSource.Instance.AddDiagnosticCounter(counter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> counter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span> key, &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)&amp;gt; GetCoreTags(HttpRequest request, HttpResponse response)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> path = request.Path.Value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrWhiteSpace(path))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (path.Length &amp;gt; &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> initialPartIndex = path.IndexOf(&lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (initialPartIndex &amp;gt; &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.Substring(&lt;span style="color:#ae81ff">0&lt;/span>, initialPartIndex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> queryIndex = path.IndexOf(&lt;span style="color:#e6db74">&amp;#39;?&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (queryIndex &amp;gt;= &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.Substring(&lt;span style="color:#ae81ff">0&lt;/span>, queryIndex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> tags = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>)&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;http-method&amp;#34;&lt;/span>, request.Method),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;http-scheme&amp;#34;&lt;/span>, request.Scheme),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;http-request-type&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;inbound&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;http-status-code&amp;#34;&lt;/span>, response.StatusCode.ToString()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;host&amp;#34;&lt;/span>, request.Host.Host), &lt;span style="color:#75715e">// host without the port value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#34;request-path&amp;#34;&lt;/span>, path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (request.Protocol.StartsWith(&lt;span style="color:#e6db74">&amp;#34;HTTP/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags.Add((&lt;span style="color:#e6db74">&amp;#34;http-version&amp;#34;&lt;/span>, request.Protocol.Substring(&lt;span style="color:#ae81ff">5&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tags;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ListOfTupleEqualityComparer&lt;/span> : EqualityComparer&amp;lt;List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>)&amp;gt;&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> Equals(List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>)&amp;gt;? left, List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>)&amp;gt;? right)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (left &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> || right &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ReferenceEquals(left, right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (left.Count != right.Count)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (left.Count == &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>; &lt;span style="color:#75715e">// Both are 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> var iterator2 = right.GetEnumerator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> element &lt;span style="color:#66d9ef">in&lt;/span> left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// second is shorter than first&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!iterator2.MoveNext())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!(element.Item1.Equals(iterator2.Current.Item1) &amp;amp;&amp;amp; element.Item2.Equals(iterator2.Current.Item2)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If we can get to the next element, first was shorter than second.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Otherwise, the sequences are equal.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> !iterator2.MoveNext();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> GetHashCode(List&amp;lt;(&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>)&amp;gt; obj)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> code = &lt;span style="color:#ae81ff">17&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreach&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> element &lt;span style="color:#66d9ef">in&lt;/span> obj)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> code = HashCode.Combine(code, element.Item1.GetHashCode(), element.Item2.GetHashCode());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> code;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Although I&amp;rsquo;ve copied the full code here for completeness, the only portion that&amp;rsquo;s really changed is the &lt;code>GetCoreTags&lt;/code> method. We needed to change this because the request/response classes that are used on the inbound request flow are different to what we used on the outbound flow. The logic, however, is largely unchanged.&lt;/p>
&lt;p>Hopefully, once everything has been bound to your IoC container, you now have all the bits that you would need to build this out in your own applications. Happy request tracking!&lt;/p></description></item><item><title>Utf8Json Media Formatters for ASP.Net Core</title><link>https://im5tu.io/article/2018/07/utf8json-media-formatters-for-asp.net-core/</link><pubDate>Sun, 29 Jul 2018 16:40:00 +0100</pubDate><guid>https://im5tu.io/article/2018/07/utf8json-media-formatters-for-asp.net-core/</guid><description>&lt;p>Recently, I have been looking at the &lt;a href="https://github.com/neuecc/Utf8Json">Utf8Json&lt;/a> project and evaluating for use in our high performance payments API. Looking at the benchmarks on the Github page, and running my own benchmarks, the numbers stated seemed to tally up, so I built a few media formatters for aspnet core.&lt;/p>
&lt;p>Now, the project does already ship with some media formatters as a separate nuget package. However, I wanted to improve the following things:&lt;/p>
&lt;ul>
&lt;li>Add support for the media type &lt;code>application/problem+json&lt;/code> by letting the server define the content type&lt;/li>
&lt;li>Return a &lt;code>NoValue&lt;/code> result on the input formatter when the request body is zero lengthed&lt;/li>
&lt;li>Only read input values when they are of type &lt;code>application/json&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Whilst not massive improvements, they may still help others. The formatters can be added via the &lt;code>InputFormatters&lt;/code>/&lt;code>OutputFormatters&lt;/code> properties when configuring the options for &lt;code>UseMvc&lt;/code>. The only problem that I am aware of, is that occassionally the deserializer does not map some camel cased proeprty names. I have dug into this problem yet as my initial evalution has finished but I suspect it&amp;rsquo;s to do with the default resolver naming convention used.&lt;/p>
&lt;h2 id="utf8json-input-media-formatter">Utf8Json Input Media Formatter&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Microsoft.AspNetCore.Mvc.Formatters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Utf8Json;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Utf8JsonInputFormatter&lt;/span> : IInputFormatter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> IJsonFormatterResolver _resolver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Utf8JsonInputFormatter() : &lt;span style="color:#66d9ef">this&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Utf8JsonInputFormatter(IJsonFormatterResolver resolver)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _resolver = resolver ?? JsonSerializer.DefaultResolver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> CanRead(InputFormatterContext context) =&amp;gt; context.HttpContext.Request.ContentType.StartsWith(&lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Task&amp;lt;InputFormatterResult&amp;gt; ReadAsync(InputFormatterContext context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> request = context.HttpContext.Request;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (request.Body.CanSeek &amp;amp;&amp;amp; request.Body.Length == &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> InputFormatterResult.NoValueAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = JsonSerializer.NonGeneric.Deserialize(context.ModelType, request.Body, _resolver);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> InputFormatterResult.SuccessAsync(result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="utf8json-output-media-formatter">Utf8Json Output Media Formatter&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Microsoft.AspNetCore.Mvc.Formatters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Utf8Json;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Utf8JsonOutputFormatter&lt;/span> : IOutputFormatter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">readonly&lt;/span> IJsonFormatterResolver _resolver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Utf8JsonOutputFormatter() : &lt;span style="color:#66d9ef">this&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Utf8JsonOutputFormatter(IJsonFormatterResolver resolver)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _resolver = resolver ?? JsonSerializer.DefaultResolver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> CanWriteResult(OutputFormatterCanWriteContext context) =&amp;gt; &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Task WriteAsync(OutputFormatterWriteContext context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!context.ContentTypeIsServerDefined)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context.HttpContext.Response.ContentType = &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (context.ObjectType == &lt;span style="color:#66d9ef">typeof&lt;/span>(&lt;span style="color:#66d9ef">object&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> JsonSerializer.NonGeneric.SerializeAsync(context.HttpContext.Response.Body, context.Object, _resolver);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> JsonSerializer.NonGeneric.SerializeAsync(context.ObjectType, context.HttpContext.Response.Body, context.Object, _resolver);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Automated Builds in VSTS with YML Build Definitions</title><link>https://im5tu.io/article/2018/06/automated-builds-in-vsts-with-yml-build-definitions/</link><pubDate>Sun, 17 Jun 2018 21:35:00 +0100</pubDate><guid>https://im5tu.io/article/2018/06/automated-builds-in-vsts-with-yml-build-definitions/</guid><description>&lt;p>In this article we will explore a preview feature inside of Visual Studio Team Services (VSTS) called YML Build Definitions. In essence, this allows you to change your build process from a &lt;code>.yml&lt;/code> file in your git repository much in the same way as you can do with other services such as AppVeyor. During the article, we will setup a build definition for an Aspnet Core website.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>Before we take a look at the struture of the file, you will need to complete the following tasks:&lt;/p>
&lt;ol>
&lt;li>Setup a git repository inside of VSTS&lt;/li>
&lt;li>Enable the preview feature (requires account level administration access)&lt;/li>
&lt;/ol>
&lt;p>For the sake of brevity, I will assume that you already have administrator access to your VSTS account and that you have a git repository already setup. If you need to know how to setup a git repository inside of VSTS, please use &lt;a href="https://docs.microsoft.com/en-us/vsts/git/create-new-repo?view=vsts">this guide&lt;/a>.&lt;/p>
&lt;p>Enabling a preview feature inside of VSTS requires that you have administration access to your account, not just your team project. If you do not have access, or unable to obtain access, you will be unable to follow the rest of the article. Once you have secured administrator level access, use the &lt;a href="https://docs.microsoft.com/en-us/vsts/project/navigation/preview-features?view=vsts">following guide&lt;/a> to enable the &amp;ldquo;YML Build Definition&amp;rdquo; preview feature.&lt;/p>
&lt;h2 id="say-hello-to-vsts-ciyml">Say hello to &lt;code>.vsts-ci.yml&lt;/code>&lt;/h2>
&lt;p>The way that VSTS has implemented the automated build system, is nothing short of excellent. They have used a convention based approach to locating the file and have built the system on top of existing tasks in your VSTS account. Unfortunately, task groups do not work as yet, but there is a templating feature which may be useful in some instances.&lt;/p>
&lt;p>In order to use the feature, you need to create a &lt;code>.vsts-ci.yml&lt;/code> file in the root of the repository. It is worth noting that this file is white-space sensitive so pay attention to that from the outset. Once this file is committed to the repository, it will automatically run everytime one or more commits are pushed to VSTS. Just like regular builds, the YML Build Definition builds integrate seamlessly into the pull request system inside of VSTS.&lt;/p>
&lt;p>The first build, once the file has been pushed, takes a little longer than use as VSTS has to create all the required build parts for the first time. In your build definitions inside of VSTS, you will see a new definition in the following naming convention:&lt;/p>
&lt;pre>&lt;code>&amp;lt;repository name&amp;gt; CI
&lt;/code>&lt;/pre>
&lt;p>If I had a repository called &lt;code>hello-world-web&lt;/code> then the build defintion that you can search for will be &lt;code>hello-world-web CI&lt;/code>.&lt;/p>
&lt;p>The file we will create follows the following structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;version number&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">triggers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;list of triggers&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;list of variables&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;our build process&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>name&lt;/code> property, from what I can tell, represents the build number which we can extract later on in the build process. &lt;code>triggers&lt;/code> allows us to only trigger when the required conditions are met. &lt;code>variables&lt;/code> are an invaluable part of the build definition. I always try and variable anything useful as the build files can become quite lengthy depending on your desired process. Lastly, &lt;code>steps&lt;/code> is where all of the build process is defined. The build files do support phases, but i am keeping that out of scope for this article. For the remainder of the article, we will assume the build number is &lt;code>0.1.0&lt;/code> or &lt;code>name: 0.1.0&lt;/code> in the yml file.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> &lt;em>At the end of this article, there is a complete file that you can use as a template.&lt;/em>&lt;/p>
&lt;h2 id="setting-up-triggers">Setting up triggers&lt;/h2>
&lt;p>If you do not specify a trigger section, VSTS will run a build for every branch that you ever commit/push to regardless of what it&amp;rsquo;s called. I usually setup my builds to automatically trigger on any feature/bugfix/release/hotfix branch and, naturally, the master branch. To do this, configure the section as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">trigger&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">branches&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">hotfix/*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">release/*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">feature/*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">bugfix/*&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The full syntax, if you choose to use it, is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">trigger&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">branches&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span>: [&lt;span style="color:#ae81ff">string]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">exclude&lt;/span>: [&lt;span style="color:#ae81ff">string]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">paths&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span>: [&lt;span style="color:#ae81ff">string]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">exclude&lt;/span>: [&lt;span style="color:#ae81ff">string]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The shorter, inclusive only syntax is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">trigger&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">string]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Personally, I prefer the full syntax, but it doesn&amp;rsquo;t make a difference as I typically only use inclusive only filters. Where &lt;code>[string]&lt;/code> is present, either place a single entry or if multiple entries are required, follow my example where I place &lt;code>-&lt;/code> on the start of each new line of the element.&lt;/p>
&lt;p>One last point to note, if you setup your branching policies in VSTS to require a build from the yml build definition, this will always be triggered regardless of the settings in this section - as far as I am aware.&lt;/p>
&lt;h2 id="using-variables">Using variables&lt;/h2>
&lt;p>You do not have to use variables in your scripts. If you decide to, they can be extremly powerful. The variables can be passed to task inputs using the macro syntax &lt;code>$(variableName)&lt;/code>, or accessed within a script using the environment variable. For an example of how the alternative syntaxes, see the &lt;a href="https://github.com/Microsoft/vsts-agent/blob/master/docs/preview/yamlgettingstarted-phase.md">documentation&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">buildConfiguration&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Release&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">buildProjects&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;**/*.csproj&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">testProjects&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;**/*Tests*.csproj&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">publishProject&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;src\CHANGEME\CHANGEME.csproj&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dotnetCliVersion&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;2.1.300&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In our script that we are building, we have some simple variables for some of the key sections of our code. It can be incredibly easy to parameterise everything, but I would advise only do that which is necessary.&lt;/p>
&lt;h2 id="the-build-pipeline">The build pipeline&lt;/h2>
&lt;p>As mentioned earlier in the article, I will be walking through how to create a build pipeline for a sample Aspnet Core website. In order for us to have something to publish-able at the end of the build, I will take you through the following:&lt;/p>
&lt;ol>
&lt;li>Cleaning the sources (Issue #4 at the end of the article)&lt;/li>
&lt;li>Ensure the dotnet CLI is installed&lt;/li>
&lt;li>Run the build in release mode&lt;/li>
&lt;li>Run the tests in release mode&lt;/li>
&lt;li>Publish the website to the artifact directory of the VSTS build&lt;/li>
&lt;li>Label the VSTS build with the build number&lt;/li>
&lt;/ol>
&lt;h2 id="cleaning-sources">Cleaning Sources&lt;/h2>
&lt;p>As a best practise, the first thing that I do in a build process is to reset the state of the repository. This prevents any issues such as false positives from previous builds etc. In order to do this, we can execute a small git magic:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">script&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> git clean -d -x -f
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> displayName: Clean Sources&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This portion is declared directly under the &lt;code>steps:&lt;/code> section in the yml file. Inline scripts, as shown above, are limited to around 500 characters at the time of writing. So you may need to get inventive with your scripts or use an external file (out of scope for this article). As the file is whitespace sensitive, there is no need for quotation marks around most things, so we can just type &lt;code>Clean Sources&lt;/code> and the space will be preserved in the name of the step when we view it inside of VSTS.&lt;/p>
&lt;p>For completeness, the git options entered are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>-d&lt;/code>: Removes untracked files&lt;/li>
&lt;li>&lt;code>-x&lt;/code>: Basically removes everything regardless of whether or not it&amp;rsquo;s in the &lt;code>.gitignore&lt;/code>&lt;/li>
&lt;li>&lt;code>-f&lt;/code>: Force the clean operation&lt;/li>
&lt;/ul>
&lt;p>In my testing, these options successfully remove the build output if present.&lt;/p>
&lt;h2 id="ensuring-the-dotnet-cli-in-installed">Ensuring the dotnet CLI in installed&lt;/h2>
&lt;p>Depending on where you are running your build process, you may or may not need this step, but I always include it for completeness. This steps checks for the specified version of the dotnet CLI and installs it if it is not present. We pull the version from a variable, which I&amp;rsquo;ll cover later.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">DotNetCoreInstaller@0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">DotNet CLI Installer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">$(dotnetCliVersion)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This should be placed under the definition of Clean Sources above. For each of the remaining steps, place them directly after the last step you entered, unless you want to change the order of the process (the build executes the steps from top to bottom - so the first one in the file is the first one to be run).&lt;/p>
&lt;h2 id="building-the-projects">Building the projects&lt;/h2>
&lt;p>In order to build the project(s), I use a two step process: restore the required nuget packages using a nuget.config file, followed by building the projects.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">DotNetCoreCLI@2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">Restore Packages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">restore&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">feedsToUse&lt;/span>: &lt;span style="color:#ae81ff">config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nugetConfigPath&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;nuget.config&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">projects&lt;/span>: &lt;span style="color:#ae81ff">$(buildProjects)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">noCache&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">verbosityRestore&lt;/span>: &lt;span style="color:#ae81ff">Normal&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above snippet, the first thing that I want to mention is that I am using a variable to decide which projects I want nuget packages to be restored for.The projects directive supports a wildcard approach, so we can declare a folder structure such as &lt;code>**/*.csproj&lt;/code> should we want to. Next, I had to set the &lt;code>noCache: true&lt;/code> directive as I always wanted the latest versions from the nuget feeds. This shouldn&amp;rsquo;t be required on hosted build servers, but may be needed for your own build servers. Lastly, I set the verbosity level back to normal, where the default is detailed. This massively cleans up the corresponding build logs. I&amp;rsquo;ll leave it up to you, the reader, to extract this to a variable should you wish too.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">DotNetCoreCLI@2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">Build Projects&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">projects&lt;/span>: &lt;span style="color:#ae81ff">$(buildProjects)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">packDirectory&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;$(Build.ArtifactStagingDirectory)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">arguments&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;-c $(buildConfiguration) /p:Version=$(Build.BuildNumber)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once again, I have used a couple of variables. The first is the projects to build which is the exact same definition as in the previous step. The second variable is the configuration that we wish to build. In this case, I always have my automated builds built in &lt;code>Release&lt;/code> mode - so this is how i&amp;rsquo;ve defined this variable. Last but by no means least, I set version number in the arguments so the assemblies are versioned correctly.&lt;/p>
&lt;h2 id="testing-the-projects">Testing the projects&lt;/h2>
&lt;p>Testing is always a part of my pipeline, regardless of whether or not the solution actually contains any tests at the current time. Luckily, if tests are not present when this step runs, then there is a only a warning on the step rather than a failing build.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">DotNetCoreCLI@2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">Test Projects&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">projects&lt;/span>: &lt;span style="color:#ae81ff">$(testProjects)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">publishTestResults&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">arguments&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;--no-build -c $(buildConfiguration)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You may of noticed that I used a separate variable for the projects that I wish to test (&lt;code>$(testProjects)&lt;/code>). For me, this is just a subset of the projects that I have already built and I always want to run in the same configuration that I built in. This allows me to pass in the &lt;code>--no-build&lt;/code> argument, saving a small amount of time on executing the tests. Luckily, the built in task for tests can automatically publish the test results (if available) via the &lt;code>publishTestResults: true&lt;/code> input.&lt;/p>
&lt;h2 id="publishing-the-website">Publishing the website&lt;/h2>
&lt;p>&lt;em>Sorry about some of the formatting in this section. See the full file at the end of this article for the proper formatting. I will sort this out eventually.&lt;/em>&lt;/p>
&lt;p>There are two steps in publishing our website. The first is to build the project with the runtime, placing the output in a staging directory. The second part is taking the build output from the staging directory and publishing it to the artificts of the build.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">DotNetCoreCLI@2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">Publish Web App&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#ae81ff">and(succeeded(), eq(variables[&amp;#39;Build.SourceBranch&amp;#39;], &amp;#39;refs/heads/master&amp;#39;))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>: &lt;span style="color:#ae81ff">publish&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">projects&lt;/span>: &lt;span style="color:#ae81ff">$(publishProject)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">arguments&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;-c Release --self-contained -r win7-x64 -o $(Build.ArtifactStagingDirectory)/drop /p:Version=$(Build.BuildNumber)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is the first time that we have used a condition. The default condition is &lt;code>succeeded()&lt;/code> which means &amp;ldquo;only run this step if the previous one completed successfully&amp;rdquo;. Here I have said, where the previous step completed successfully and the branch that&amp;rsquo;s being built is the &lt;code>master&lt;/code> branch. For some of our builds we only publish on the master branch, though it can be handy to have this step in place for pull requests etc. It purely depends on the requirements on your build pipeline.&lt;/p>
&lt;p>Taking a look at the arguments, I want to point out the use of: &lt;code>--self-contained&lt;/code>, &lt;code>-r&lt;/code> and &lt;code>-o&lt;/code>. They have the following attributes:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--self-contained&lt;/code>: Publish the .NET Core runtime with your application so the runtime doesn&amp;rsquo;t need to be installed on the target machine.&lt;/li>
&lt;li>&lt;code>-r &amp;lt;runtime&amp;gt;&lt;/code>: Publish the project for a given runtime.&lt;/li>
&lt;li>&lt;code>-o &amp;lt;directory&amp;gt;&lt;/code>: This places the build output into the specified directory. In our case, it&amp;rsquo;s a folder called &lt;code>drop&lt;/code> inside of the VSTS staging directory. You do not need to manually create these folders, VSTS takes care of this for you.&lt;/li>
&lt;/ul>
&lt;p>The next step is to publish the artifacts so we can use it after the build completes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">PublishBuildArtifacts@1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#ae81ff">and(succeeded(), eq(variables[&amp;#39;Build.SourceBranch&amp;#39;], &amp;#39;refs/heads/master&amp;#39;))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pathtoPublish&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;$(Build.ArtifactStagingDirectory)/drop&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">artifactName&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;drop&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">publishLocation&lt;/span>: &lt;span style="color:#ae81ff">Container&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This step takes the contents of the &lt;code>drop&lt;/code> folder in the staging area, and copies it to the published artifacts &lt;code>drop&lt;/code> directory. Occassionally, I build and package multiple projects, so I have them split out in the staging/published areas in separate folders. This, however, is not required.&lt;/p>
&lt;h2 id="labelling-the-build">Labelling the Build&lt;/h2>
&lt;p>This section requires the &lt;a href="https://marketplace.visualstudio.com/items?itemName=YodLabs.VariableTasks">following extension&lt;/a> to be installed. Though there may be another, built in, way to complete the same task. In my real builds, I usually have multiple tags for our release process. To add additional tags, enter another line at the same indentation as &lt;code>Build-$(Build.BuildNumber)&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">task&lt;/span>: &lt;span style="color:#ae81ff">YodLabs.VariableTasks.AddTag.AddTag@0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">displayName&lt;/span>: &lt;span style="color:#ae81ff">Tag VSTS Build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">condition&lt;/span>: &lt;span style="color:#ae81ff">and(succeeded(), eq(variables[&amp;#39;Build.SourceBranch&amp;#39;], &amp;#39;refs/heads/master&amp;#39;))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">inputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tags&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Build-$(Build.BuildNumber)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this task completes, you should have a tag on your build like: &lt;code>Build-0.1.0&lt;/code>.&lt;/p>
&lt;h2 id="final-file">Final file&lt;/h2>
&lt;p>As I mentioned near the start of the article, the &lt;code>.vsts-ci.yml&lt;/code> file is whitespace sensitive, so for completeness, here is a sample file that you can use for your own builds.&lt;/p>
&lt;script src="https://gist.github.com/Im5tu/3ed84e07f4db212440b56a4b84d4ad3e.js">&lt;/script>
&lt;h2 id="teaching-yourself">Teaching yourself&lt;/h2>
&lt;p>Although I have covered a very basic process here, there are two ways that you can discover the features currently available in the preview feature. Firstly, you can create a build definition manually adding in the relevant tasks to your process. Once you are ready, click on the phase that you are interested in then look for the &lt;code>View YAML&lt;/code> option in the right hand pane. Alternatively, there is the &lt;a href="https://github.com/Microsoft/vsts-agent/blob/master/docs/preview/yamlgettingstarted.md">preview documentation&lt;/a>. I used both approaches to teach myself how to do the builds. The documentation could do with a little bit more detail in places, so a lot of this is currently experimentation.&lt;/p>
&lt;h2 id="potential-issues">Potential Issues&lt;/h2>
&lt;p>I wanted to include this section, because there are a few things that I have noticed that doesn&amp;rsquo;t quite work as expected, or at all in some cases:&lt;/p>
&lt;ol>
&lt;li>Changing the queue using the &lt;code>queue:&lt;/code> setting does not appear to work. I have tried using a variety of syntaxes in a few different places (top level/phases) but nothing seems to work at the moment. So you have to change the build manually if this is an issue for you.&lt;/li>
&lt;li>In order to perform git operations from the command line, you need to either:
&lt;ul>
&lt;li>Use the VSTS API and API token system to perform the action&lt;/li>
&lt;li>Give the project collection build user account &lt;code>Contributor&lt;/code> access to your repository&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>When I experimented with using the git command line to tag our repositories, the command to push to the repository seemed never to complete or timeout (it was &amp;ldquo;pushing&amp;rdquo; for well over 5 minutes)&lt;/li>
&lt;li>You can get build server re-use which can lead to incremental builds rather than a clean build, which can have some disasterous consequences. So for all of my builds, I force git to clean all of the sources before I do anything for the current build.&lt;/li>
&lt;/ol>
&lt;p>I&amp;rsquo;m sure that all of these issues will be resolved in due course as more and more support is added to the feature. It is well worth using if it works for your scenario. In a future article, I will show you how to publish a SQL project, Service Fabric project and Nuget package all from a YML Build Definition.&lt;/p></description></item><item><title>Enabling HTTP Strict Transport Security HSTS via ASP Net MVC ActionFilters</title><link>https://im5tu.io/article/2014/04/enabling-http-strict-transport-security-hsts-via-asp-net-mvc-actionfilters/</link><pubDate>Mon, 21 Apr 2014 18:19:47 +0000</pubDate><guid>https://im5tu.io/article/2014/04/enabling-http-strict-transport-security-hsts-via-asp-net-mvc-actionfilters/</guid><description>&lt;p>After reading &lt;a href="http://www.troyhunt.com/">Troy Hunt&amp;rsquo;s&lt;/a> free ebook on the &lt;a href="http://www.troyhunt.com/2011/12/free-ebook-owasp-top-10-for-net.html">OWASP Top 10 for .Net Developers&lt;/a>, I discovered an additional mechanism to help developers secure their websites. That mechanism is HTTP Strict Transport Security.&lt;/p>
&lt;blockquote>
&lt;p>HTTP Strict Transport Security (HSTS) is an opt-in security enhancement that is specified by a web application through the use of a special response header. Once a supported browser receives this header that browser will prevent any communications from being sent over HTTP to the specified domain and will instead send all communications over HTTPS. It also prevents HTTPS click through prompts on browsers. The specification has been released and published end of 2012 as &lt;a href="https://tools.ietf.org/html/rfc6797">RFC 6797&lt;/a>. &lt;a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security">Source&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>There are three main categories of attacks that are addressed in this specification: Passive Network Attacks, Active Network Attacks and Web Site Development &amp;amp; Deployment Bugs. These are present in &lt;a href="https://tools.ietf.org/html/rfc6797">RFC 6797 - Section 2.3.1&lt;/a> but are re-produced here.&lt;/p>
&lt;h2 id="passive-network-attacks">Passive Network Attacks&lt;/h2>
&lt;blockquote>
&lt;p>When a user browses the web on a local wireless network (e.g., an
802.11-based wireless local area network) a nearby attacker can
possibly eavesdrop on the user&amp;rsquo;s unencrypted Internet Protocol-based
connections, such as HTTP, regardless of whether or not the local
wireless network itself is secured [BeckTews09]. Freely available
wireless sniffing toolkits (e.g., [Aircrack-ng]) enable such passive
eavesdropping attacks, even if the local wireless network is
operating in a secure fashion. A passive network attacker using such
tools can steal session identifiers/cookies and hijack the user&amp;rsquo;s web
session(s) by obtaining cookies containing authentication credentials
[ForceHTTPS]. For example, there exist widely available tools, such
as Firesheep (a web browser extension) [Firesheep], that enable their
wielder to obtain other local users&amp;rsquo; session cookies for various web
applications.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>To mitigate such threats, some web sites support, but usually do not
force, access using end-to-end secure transport &amp;ndash; e.g., signaled
through URIs constructed with the &amp;ldquo;https&amp;rdquo; scheme [RFC2818]. This can
lead users to believe that accessing such services using secure
transport protects them from passive network attackers.
Unfortunately, this is often not the case in real-world deployments,
as session identifiers are often stored in non-Secure cookies to
permit interoperability with versions of the service offered over
insecure transport (&amp;ldquo;Secure cookies&amp;rdquo; are those cookies containing the
&amp;ldquo;Secure&amp;rdquo; attribute [RFC6265]). For example, if the session
identifier for a web site (an email service, say) is stored in a
non-Secure cookie, it permits an attacker to hijack the user&amp;rsquo;s
session if the user&amp;rsquo;s UA makes a single insecure HTTP request to the
site.&lt;/p>
&lt;/blockquote>
&lt;h2 id="active-network-attacks">Active Network Attacks&lt;/h2>
&lt;blockquote>
&lt;p>A determined attacker can mount an active attack, either by
impersonating a user&amp;rsquo;s DNS server or, in a wireless network, by
spoofing network frames or offering a similarly named evil twin
access point. If the user is behind a wireless home router, an
attacker can attempt to reconfigure the router using default
passwords and other vulnerabilities. Some sites, such as banks, rely
on end-to-end secure transport to protect themselves and their users
from such active attackers. Unfortunately, browsers allow their
users to easily opt out of these protections in order to be usable for sites that incorrectly deploy secure transport, for example by
generating and self-signing their own certificates (without also
distributing their certification authority (CA) certificate to their
users&amp;rsquo; browsers).&lt;/p>
&lt;/blockquote>
&lt;h2 id="website-development--deployment-bugs">Website Development &amp;amp; Deployment Bugs&lt;/h2>
&lt;blockquote>
&lt;p>The security of an otherwise uniformly secure site (i.e., all of its
content is materialized via &amp;ldquo;https&amp;rdquo; URIs) can be compromised
completely by an active attacker exploiting a simple mistake, such as
the loading of a cascading style sheet or a SWF (Shockwave Flash)
movie over an insecure connection (both cascading style sheets and
SWF movies can script the embedding page, to the surprise of many web
developers, plus some browsers do not issue so-called &amp;ldquo;mixed content
warnings&amp;rdquo; when SWF files are embedded via insecure connections).
Even if the site&amp;rsquo;s developers carefully scrutinize their login page
for &amp;ldquo;mixed content&amp;rdquo;, a single insecure embedding anywhere on the
overall site compromises the security of their login page because an
attacker can script (i.e., control) the login page by injecting code
(e.g., a script) into another, insecurely loaded, site page.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>NOTE: &amp;ldquo;Mixed content&amp;rdquo; as used above (see also Section 5.3 in
[W3C.REC-wsc-ui-20100812]) refers to the notion termed &amp;ldquo;mixed
security context&amp;rdquo; in this specification and should not be
confused with the same &amp;ldquo;mixed content&amp;rdquo; term used in the
context of markup languages such as XML and HTML.&lt;/p>
&lt;/blockquote>
&lt;h2 id="implementation-details">Implementation Details&lt;/h2>
&lt;p>Implementing the HSTS from the web server is simply a case of having the site running over HTTPS and appending a single header onto the response. The header required is:&lt;/p>
&lt;pre>&lt;code>Strict-Transport-Security: max-age=300
&lt;/code>&lt;/pre>
&lt;p>Alternatively, if you wish the security to cover all sub-domains of your site, then the header is:&lt;/p>
&lt;pre>&lt;code>Strict-Transport-Security: max-age=300; includeSubDomains
&lt;/code>&lt;/pre>
&lt;p>&lt;em>Where 300 is, replace with the duration in seconds.&lt;/em>&lt;/p>
&lt;h2 id="implementing-hsts-as-an-action-filter">Implementing HSTS as an action filter&lt;/h2>
&lt;p>The implementation that I provide below &lt;strong>SHOULD&lt;/strong> be used alongside the &lt;code>RequireHttpsAttribute&lt;/code> in order to have the specification fully implemented. The reason is that the header will only be sent over a secure connection, if not already present. Furthermore, the &lt;code>RequireHttpsAttribute&lt;/code> already takes care of the redirection to a secure connection, so this is not something that I have to worry about implementing correctly.&lt;/p>
&lt;h2 id="browser-support">Browser support&lt;/h2>
&lt;ul>
&lt;li>Chromium and Google Chrome since version 4.0.211.0&lt;/li>
&lt;li>Firefox since version 4; with Firefox 17, Mozilla integrates a list of websites supporting HSTS&lt;/li>
&lt;li>Opera since version 12&lt;/li>
&lt;li>Safari as of OS X Mavericks&lt;/li>
&lt;li>Internet Explorer does not support HSTS, but is expected to support it in the next major release after IE 11&lt;/li>
&lt;/ul></description></item></channel></rss>